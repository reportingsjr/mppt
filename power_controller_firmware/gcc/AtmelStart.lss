
AtmelStart.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000c4c  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000000  20000000  20000000  00010c4c  2**0
                  CONTENTS
  2 .bss          00000060  20000000  20000000  00020000  2**2
                  ALLOC
  3 .stack        00002000  20000060  20000060  00020000  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  00010c4c  2**0
                  CONTENTS, READONLY
  5 .comment      00000042  00000000  00000000  00010c74  2**0
                  CONTENTS, READONLY
  6 .debug_info   0001ef44  00000000  00000000  00010cb6  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002381  00000000  00000000  0002fbfa  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00007196  00000000  00000000  00031f7b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 000008a0  00000000  00000000  00039118  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00001998  00000000  00000000  000399b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  00004fbe  00000000  00000000  0003b350  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00009366  00000000  00000000  0004030e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0008252f  00000000  00000000  00049674  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  0000165c  00000000  00000000  000cbba4  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
   0:	60 20 00 20 51 01 00 00 4d 01 00 00 4d 01 00 00     ` . Q...M...M...
	...
  2c:	4d 01 00 00 00 00 00 00 00 00 00 00 4d 01 00 00     M...........M...
  3c:	4d 01 00 00 4d 01 00 00 4d 01 00 00 4d 01 00 00     M...M...M...M...
  4c:	4d 01 00 00 4d 01 00 00 4d 01 00 00 4d 01 00 00     M...M...M...M...
  5c:	4d 01 00 00 4d 01 00 00 4d 01 00 00 4d 01 00 00     M...M...M...M...
  6c:	4d 01 00 00 4d 01 00 00 4d 01 00 00 4d 01 00 00     M...M...M...M...
  7c:	4d 01 00 00 29 0a 00 00 4d 01 00 00 4d 01 00 00     M...)...M...M...
  8c:	4d 01 00 00 4d 01 00 00 00 00 00 00 00 00 00 00     M...M...........
  9c:	4d 01 00 00 4d 01 00 00 4d 01 00 00 4d 01 00 00     M...M...M...M...
  ac:	4d 01 00 00 00 00 00 00                             M.......

000000b4 <deregister_tm_clones>:
  b4:	4804      	ldr	r0, [pc, #16]	; (c8 <deregister_tm_clones+0x14>)
  b6:	4b05      	ldr	r3, [pc, #20]	; (cc <deregister_tm_clones+0x18>)
  b8:	b510      	push	{r4, lr}
  ba:	4283      	cmp	r3, r0
  bc:	d003      	beq.n	c6 <deregister_tm_clones+0x12>
  be:	4b04      	ldr	r3, [pc, #16]	; (d0 <deregister_tm_clones+0x1c>)
  c0:	2b00      	cmp	r3, #0
  c2:	d000      	beq.n	c6 <deregister_tm_clones+0x12>
  c4:	4798      	blx	r3
  c6:	bd10      	pop	{r4, pc}
  c8:	00000c4c 	.word	0x00000c4c
  cc:	00000c4c 	.word	0x00000c4c
  d0:	00000000 	.word	0x00000000

000000d4 <register_tm_clones>:
  d4:	4806      	ldr	r0, [pc, #24]	; (f0 <register_tm_clones+0x1c>)
  d6:	4907      	ldr	r1, [pc, #28]	; (f4 <register_tm_clones+0x20>)
  d8:	1a09      	subs	r1, r1, r0
  da:	1089      	asrs	r1, r1, #2
  dc:	0fcb      	lsrs	r3, r1, #31
  de:	1859      	adds	r1, r3, r1
  e0:	b510      	push	{r4, lr}
  e2:	1049      	asrs	r1, r1, #1
  e4:	d003      	beq.n	ee <register_tm_clones+0x1a>
  e6:	4b04      	ldr	r3, [pc, #16]	; (f8 <register_tm_clones+0x24>)
  e8:	2b00      	cmp	r3, #0
  ea:	d000      	beq.n	ee <register_tm_clones+0x1a>
  ec:	4798      	blx	r3
  ee:	bd10      	pop	{r4, pc}
  f0:	00000c4c 	.word	0x00000c4c
  f4:	00000c4c 	.word	0x00000c4c
  f8:	00000000 	.word	0x00000000

000000fc <__do_global_dtors_aux>:
  fc:	b510      	push	{r4, lr}
  fe:	4c07      	ldr	r4, [pc, #28]	; (11c <__do_global_dtors_aux+0x20>)
 100:	7823      	ldrb	r3, [r4, #0]
 102:	2b00      	cmp	r3, #0
 104:	d109      	bne.n	11a <__do_global_dtors_aux+0x1e>
 106:	f7ff ffd5 	bl	b4 <deregister_tm_clones>
 10a:	4b05      	ldr	r3, [pc, #20]	; (120 <__do_global_dtors_aux+0x24>)
 10c:	2b00      	cmp	r3, #0
 10e:	d002      	beq.n	116 <__do_global_dtors_aux+0x1a>
 110:	4804      	ldr	r0, [pc, #16]	; (124 <__do_global_dtors_aux+0x28>)
 112:	e000      	b.n	116 <__do_global_dtors_aux+0x1a>
 114:	bf00      	nop
 116:	2301      	movs	r3, #1
 118:	7023      	strb	r3, [r4, #0]
 11a:	bd10      	pop	{r4, pc}
 11c:	20000000 	.word	0x20000000
 120:	00000000 	.word	0x00000000
 124:	00000c4c 	.word	0x00000c4c

00000128 <frame_dummy>:
 128:	4b05      	ldr	r3, [pc, #20]	; (140 <frame_dummy+0x18>)
 12a:	b510      	push	{r4, lr}
 12c:	2b00      	cmp	r3, #0
 12e:	d003      	beq.n	138 <frame_dummy+0x10>
 130:	4904      	ldr	r1, [pc, #16]	; (144 <frame_dummy+0x1c>)
 132:	4805      	ldr	r0, [pc, #20]	; (148 <frame_dummy+0x20>)
 134:	e000      	b.n	138 <frame_dummy+0x10>
 136:	bf00      	nop
 138:	f7ff ffcc 	bl	d4 <register_tm_clones>
 13c:	bd10      	pop	{r4, pc}
 13e:	46c0      	nop			; (mov r8, r8)
 140:	00000000 	.word	0x00000000
 144:	20000004 	.word	0x20000004
 148:	00000c4c 	.word	0x00000c4c

0000014c <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
 14c:	e7fe      	b.n	14c <Dummy_Handler>
	...

00000150 <Reset_Handler>:
	if (pSrc != pDest) {
 150:	4821      	ldr	r0, [pc, #132]	; (1d8 <Reset_Handler+0x88>)
 152:	4922      	ldr	r1, [pc, #136]	; (1dc <Reset_Handler+0x8c>)
{
 154:	b570      	push	{r4, r5, r6, lr}
 156:	2300      	movs	r3, #0
	if (pSrc != pDest) {
 158:	4288      	cmp	r0, r1
 15a:	d135      	bne.n	1c8 <Reset_Handler+0x78>
		*pDest++ = 0;
 15c:	2100      	movs	r1, #0
 15e:	4b20      	ldr	r3, [pc, #128]	; (1e0 <Reset_Handler+0x90>)
	for (pDest = &_szero; pDest < &_ezero;) {
 160:	4a20      	ldr	r2, [pc, #128]	; (1e4 <Reset_Handler+0x94>)
 162:	4293      	cmp	r3, r2
 164:	d335      	bcc.n	1d2 <Reset_Handler+0x82>
	SCB->VTOR = ((uint32_t)pSrc & SCB_VTOR_TBLOFF_Msk);
 166:	22ff      	movs	r2, #255	; 0xff
 168:	4b1f      	ldr	r3, [pc, #124]	; (1e8 <Reset_Handler+0x98>)
	USB->DEVICE.QOSCTRL.bit.CQOS = 2;
 16a:	2103      	movs	r1, #3
	SCB->VTOR = ((uint32_t)pSrc & SCB_VTOR_TBLOFF_Msk);
 16c:	4393      	bics	r3, r2
 16e:	4a1f      	ldr	r2, [pc, #124]	; (1ec <Reset_Handler+0x9c>)
	USB->DEVICE.QOSCTRL.bit.DQOS = 2;
 170:	250c      	movs	r5, #12
	SCB->VTOR = ((uint32_t)pSrc & SCB_VTOR_TBLOFF_Msk);
 172:	6093      	str	r3, [r2, #8]
	SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
 174:	2202      	movs	r2, #2
	USB->DEVICE.QOSCTRL.bit.DQOS = 2;
 176:	2408      	movs	r4, #8
	DMAC->QOSCTRL.bit.DQOS   = 2;
 178:	2630      	movs	r6, #48	; 0x30
	SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
 17a:	4b1d      	ldr	r3, [pc, #116]	; (1f0 <Reset_Handler+0xa0>)
	USB->DEVICE.QOSCTRL.bit.CQOS = 2;
 17c:	481d      	ldr	r0, [pc, #116]	; (1f4 <Reset_Handler+0xa4>)
	SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
 17e:	625a      	str	r2, [r3, #36]	; 0x24
	USB->DEVICE.QOSCTRL.bit.CQOS = 2;
 180:	78c3      	ldrb	r3, [r0, #3]
 182:	438b      	bics	r3, r1
 184:	4313      	orrs	r3, r2
 186:	70c3      	strb	r3, [r0, #3]
	USB->DEVICE.QOSCTRL.bit.DQOS = 2;
 188:	78c3      	ldrb	r3, [r0, #3]
 18a:	43ab      	bics	r3, r5
 18c:	4323      	orrs	r3, r4
 18e:	70c3      	strb	r3, [r0, #3]
	DMAC->QOSCTRL.bit.DQOS   = 2;
 190:	4b19      	ldr	r3, [pc, #100]	; (1f8 <Reset_Handler+0xa8>)
 192:	7b98      	ldrb	r0, [r3, #14]
 194:	43b0      	bics	r0, r6
 196:	0006      	movs	r6, r0
 198:	2020      	movs	r0, #32
 19a:	4330      	orrs	r0, r6
 19c:	7398      	strb	r0, [r3, #14]
	DMAC->QOSCTRL.bit.FQOS   = 2;
 19e:	7b98      	ldrb	r0, [r3, #14]
 1a0:	43a8      	bics	r0, r5
 1a2:	4304      	orrs	r4, r0
 1a4:	739c      	strb	r4, [r3, #14]
	DMAC->QOSCTRL.bit.WRBQOS = 2;
 1a6:	7b98      	ldrb	r0, [r3, #14]
 1a8:	4388      	bics	r0, r1
 1aa:	4302      	orrs	r2, r0
 1ac:	739a      	strb	r2, [r3, #14]
	NVMCTRL->CTRLB.bit.MANW = 1;
 1ae:	2380      	movs	r3, #128	; 0x80
 1b0:	4a12      	ldr	r2, [pc, #72]	; (1fc <Reset_Handler+0xac>)
 1b2:	6851      	ldr	r1, [r2, #4]
 1b4:	430b      	orrs	r3, r1
 1b6:	6053      	str	r3, [r2, #4]
	__libc_init_array();
 1b8:	4b11      	ldr	r3, [pc, #68]	; (200 <Reset_Handler+0xb0>)
 1ba:	4798      	blx	r3
	main();
 1bc:	4b11      	ldr	r3, [pc, #68]	; (204 <Reset_Handler+0xb4>)
 1be:	4798      	blx	r3
 1c0:	e7fe      	b.n	1c0 <Reset_Handler+0x70>
			*pDest++ = *pSrc++;
 1c2:	58c4      	ldr	r4, [r0, r3]
 1c4:	3304      	adds	r3, #4
 1c6:	6014      	str	r4, [r2, #0]
		for (; pDest < &_erelocate;) {
 1c8:	4c0f      	ldr	r4, [pc, #60]	; (208 <Reset_Handler+0xb8>)
 1ca:	18ca      	adds	r2, r1, r3
 1cc:	42a2      	cmp	r2, r4
 1ce:	d3f8      	bcc.n	1c2 <Reset_Handler+0x72>
 1d0:	e7c4      	b.n	15c <Reset_Handler+0xc>
		*pDest++ = 0;
 1d2:	c302      	stmia	r3!, {r1}
 1d4:	e7c5      	b.n	162 <Reset_Handler+0x12>
 1d6:	46c0      	nop			; (mov r8, r8)
 1d8:	00000c4c 	.word	0x00000c4c
 1dc:	20000000 	.word	0x20000000
 1e0:	20000000 	.word	0x20000000
 1e4:	20000060 	.word	0x20000060
 1e8:	00000000 	.word	0x00000000
 1ec:	e000ed00 	.word	0xe000ed00
 1f0:	410070fc 	.word	0x410070fc
 1f4:	41005000 	.word	0x41005000
 1f8:	41004800 	.word	0x41004800
 1fc:	41004000 	.word	0x41004000
 200:	00000b85 	.word	0x00000b85
 204:	00000431 	.word	0x00000431
 208:	20000000 	.word	0x20000000

0000020c <i2c_m_sync_write>:

/**
 * \brief Sync version of I2C I/O write
 */
static int32_t i2c_m_sync_write(struct io_descriptor *io, const uint8_t *buf, const uint16_t n)
{
 20c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 20e:	0014      	movs	r4, r2
	struct i2c_m_sync_desc *i2c = CONTAINER_OF(io, struct i2c_m_sync_desc, io);
	struct _i2c_m_msg       msg;
	int32_t                 ret;

	msg.addr   = i2c->slave_addr;
 210:	3814      	subs	r0, #20
 212:	8b82      	ldrh	r2, [r0, #28]
 214:	ab01      	add	r3, sp, #4
 216:	801a      	strh	r2, [r3, #0]
	msg.len    = n;
	msg.flags  = I2C_M_STOP;
 218:	4a05      	ldr	r2, [pc, #20]	; (230 <i2c_m_sync_write+0x24>)
	msg.buffer = (uint8_t *)buf;
 21a:	9103      	str	r1, [sp, #12]
	msg.flags  = I2C_M_STOP;
 21c:	805a      	strh	r2, [r3, #2]

	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
 21e:	0019      	movs	r1, r3
 220:	4b04      	ldr	r3, [pc, #16]	; (234 <i2c_m_sync_write+0x28>)
	msg.len    = n;
 222:	9402      	str	r4, [sp, #8]
	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
 224:	4798      	blx	r3

	if (ret) {
 226:	2800      	cmp	r0, #0
 228:	d100      	bne.n	22c <i2c_m_sync_write+0x20>
		return ret;
	}

	return n;
 22a:	0020      	movs	r0, r4
}
 22c:	b004      	add	sp, #16
 22e:	bd10      	pop	{r4, pc}
 230:	ffff8000 	.word	0xffff8000
 234:	00000889 	.word	0x00000889

00000238 <i2c_m_sync_read>:
{
 238:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 23a:	0014      	movs	r4, r2
	msg.addr   = i2c->slave_addr;
 23c:	3814      	subs	r0, #20
 23e:	8b82      	ldrh	r2, [r0, #28]
 240:	ab01      	add	r3, sp, #4
 242:	801a      	strh	r2, [r3, #0]
	msg.flags  = I2C_M_STOP | I2C_M_RD;
 244:	4a05      	ldr	r2, [pc, #20]	; (25c <i2c_m_sync_read+0x24>)
	msg.buffer = buf;
 246:	9103      	str	r1, [sp, #12]
	msg.flags  = I2C_M_STOP | I2C_M_RD;
 248:	805a      	strh	r2, [r3, #2]
	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
 24a:	0019      	movs	r1, r3
 24c:	4b04      	ldr	r3, [pc, #16]	; (260 <i2c_m_sync_read+0x28>)
	msg.len    = n;
 24e:	9402      	str	r4, [sp, #8]
	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
 250:	4798      	blx	r3
	if (ret) {
 252:	2800      	cmp	r0, #0
 254:	d100      	bne.n	258 <i2c_m_sync_read+0x20>
	return n;
 256:	0020      	movs	r0, r4
}
 258:	b004      	add	sp, #16
 25a:	bd10      	pop	{r4, pc}
 25c:	ffff8001 	.word	0xffff8001
 260:	00000889 	.word	0x00000889

00000264 <i2c_m_sync_init>:

/**
 * \brief Sync version of i2c initialize
 */
int32_t i2c_m_sync_init(struct i2c_m_sync_desc *i2c, void *hw)
{
 264:	b570      	push	{r4, r5, r6, lr}
 266:	0004      	movs	r4, r0
	int32_t init_status;
	ASSERT(i2c);
 268:	1e43      	subs	r3, r0, #1
 26a:	4198      	sbcs	r0, r3
{
 26c:	000d      	movs	r5, r1
	ASSERT(i2c);
 26e:	b2c0      	uxtb	r0, r0
 270:	4907      	ldr	r1, [pc, #28]	; (290 <i2c_m_sync_init+0x2c>)
 272:	4b08      	ldr	r3, [pc, #32]	; (294 <i2c_m_sync_init+0x30>)
 274:	225e      	movs	r2, #94	; 0x5e
 276:	4798      	blx	r3

	init_status = _i2c_m_sync_init(&i2c->device, hw);
 278:	0029      	movs	r1, r5
 27a:	0020      	movs	r0, r4
 27c:	4b06      	ldr	r3, [pc, #24]	; (298 <i2c_m_sync_init+0x34>)
 27e:	4798      	blx	r3
	if (init_status) {
 280:	2800      	cmp	r0, #0
 282:	d103      	bne.n	28c <i2c_m_sync_init+0x28>
		return init_status;
	}

	/* Init I/O */
	i2c->io.read  = i2c_m_sync_read;
 284:	4b05      	ldr	r3, [pc, #20]	; (29c <i2c_m_sync_init+0x38>)
 286:	61a3      	str	r3, [r4, #24]
	i2c->io.write = i2c_m_sync_write;
 288:	4b05      	ldr	r3, [pc, #20]	; (2a0 <i2c_m_sync_init+0x3c>)
 28a:	6163      	str	r3, [r4, #20]

	return ERR_NONE;
}
 28c:	bd70      	pop	{r4, r5, r6, pc}
 28e:	46c0      	nop			; (mov r8, r8)
 290:	00000bcc 	.word	0x00000bcc
 294:	00000351 	.word	0x00000351
 298:	00000859 	.word	0x00000859
 29c:	00000239 	.word	0x00000239
 2a0:	0000020d 	.word	0x0000020d

000002a4 <delay_init>:

/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
 2a4:	b510      	push	{r4, lr}
	_delay_init(hardware = hw);
 2a6:	4b02      	ldr	r3, [pc, #8]	; (2b0 <delay_init+0xc>)
 2a8:	6018      	str	r0, [r3, #0]
 2aa:	4b02      	ldr	r3, [pc, #8]	; (2b4 <delay_init+0x10>)
 2ac:	4798      	blx	r3
}
 2ae:	bd10      	pop	{r4, pc}
 2b0:	2000001c 	.word	0x2000001c
 2b4:	00000349 	.word	0x00000349

000002b8 <delay_ms>:
/**
 * \brief Perform delay in ms
 */
void delay_ms(const uint16_t ms)
{
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
 2b8:	4b04      	ldr	r3, [pc, #16]	; (2cc <delay_ms+0x14>)
{
 2ba:	b510      	push	{r4, lr}
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
 2bc:	681c      	ldr	r4, [r3, #0]
 2be:	4b04      	ldr	r3, [pc, #16]	; (2d0 <delay_ms+0x18>)
 2c0:	4798      	blx	r3
 2c2:	4b04      	ldr	r3, [pc, #16]	; (2d4 <delay_ms+0x1c>)
 2c4:	0001      	movs	r1, r0
 2c6:	0020      	movs	r0, r4
 2c8:	4798      	blx	r3
}
 2ca:	bd10      	pop	{r4, pc}
 2cc:	2000001c 	.word	0x2000001c
 2d0:	0000032d 	.word	0x0000032d
 2d4:	0000034b 	.word	0x0000034b

000002d8 <_pm_init>:
}

static inline void hri_pm_set_CPUSEL_CPUDIV_bf(const void *const hw, hri_pm_cpusel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->CPUSEL.reg |= PM_CPUSEL_CPUDIV(mask);
 2d8:	4b06      	ldr	r3, [pc, #24]	; (2f4 <_pm_init+0x1c>)
 2da:	7a1a      	ldrb	r2, [r3, #8]
 2dc:	b2d2      	uxtb	r2, r2
 2de:	721a      	strb	r2, [r3, #8]
}

static inline void hri_pm_set_APBASEL_APBADIV_bf(const void *const hw, hri_pm_apbasel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBASEL.reg |= PM_APBASEL_APBADIV(mask);
 2e0:	7a5a      	ldrb	r2, [r3, #9]
 2e2:	b2d2      	uxtb	r2, r2
 2e4:	725a      	strb	r2, [r3, #9]
}

static inline void hri_pm_set_APBBSEL_APBBDIV_bf(const void *const hw, hri_pm_apbbsel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBBSEL.reg |= PM_APBBSEL_APBBDIV(mask);
 2e6:	7a9a      	ldrb	r2, [r3, #10]
 2e8:	b2d2      	uxtb	r2, r2
 2ea:	729a      	strb	r2, [r3, #10]
}

static inline void hri_pm_set_APBCSEL_APBCDIV_bf(const void *const hw, hri_pm_apbcsel_reg_t mask)
{
	PM_CRITICAL_SECTION_ENTER();
	((Pm *)hw)->APBCSEL.reg |= PM_APBCSEL_APBCDIV(mask);
 2ec:	7ada      	ldrb	r2, [r3, #11]
 2ee:	b2d2      	uxtb	r2, r2
 2f0:	72da      	strb	r2, [r3, #11]
{
	hri_pm_set_CPUSEL_CPUDIV_bf(PM, CONF_CPU_DIV);
	hri_pm_set_APBASEL_APBADIV_bf(PM, CONF_APBA_DIV);
	hri_pm_set_APBBSEL_APBBDIV_bf(PM, CONF_APBB_DIV);
	hri_pm_set_APBCSEL_APBCDIV_bf(PM, CONF_APBC_DIV);
}
 2f2:	4770      	bx	lr
 2f4:	40000400 	.word	0x40000400

000002f8 <_init_chip>:
}

static inline void hri_nvmctrl_set_CTRLB_RWS_bf(const void *const hw, hri_nvmctrl_ctrlb_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg |= NVMCTRL_CTRLB_RWS(mask);
 2f8:	4b07      	ldr	r3, [pc, #28]	; (318 <_init_chip+0x20>)

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
 2fa:	b510      	push	{r4, lr}
 2fc:	685a      	ldr	r2, [r3, #4]
 2fe:	605a      	str	r2, [r3, #4]
	hri_nvmctrl_set_CTRLB_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_pm_init();
 300:	4b06      	ldr	r3, [pc, #24]	; (31c <_init_chip+0x24>)
 302:	4798      	blx	r3
	_sysctrl_init_sources();
 304:	4b06      	ldr	r3, [pc, #24]	; (320 <_init_chip+0x28>)
 306:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
 308:	2008      	movs	r0, #8
 30a:	4c06      	ldr	r4, [pc, #24]	; (324 <_init_chip+0x2c>)
 30c:	47a0      	blx	r4
#endif
	_sysctrl_init_referenced_generators();
 30e:	4b06      	ldr	r3, [pc, #24]	; (328 <_init_chip+0x30>)
 310:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
 312:	20f7      	movs	r0, #247	; 0xf7
 314:	47a0      	blx	r4
#if CONF_DMAC_ENABLE
	_pm_enable_bus_clock(PM_BUS_AHB, DMAC);
	_pm_enable_bus_clock(PM_BUS_APBB, DMAC);
	_dma_init();
#endif
}
 316:	bd10      	pop	{r4, pc}
 318:	41004000 	.word	0x41004000
 31c:	000002d9 	.word	0x000002d9
 320:	00000359 	.word	0x00000359
 324:	000003f5 	.word	0x000003f5
 328:	00000389 	.word	0x00000389

0000032c <_get_cycles_for_ms>:

/**
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
uint32_t _get_cycles_for_ms(const uint16_t ms)
{
 32c:	0003      	movs	r3, r0
		return (ms * (freq / 100000) + 2) / 3 * 100;
 32e:	20f0      	movs	r0, #240	; 0xf0
 330:	0040      	lsls	r0, r0, #1
 332:	4358      	muls	r0, r3
{
 334:	b510      	push	{r4, lr}
		return (ms * (freq / 100000) + 2) / 3 * 100;
 336:	4b03      	ldr	r3, [pc, #12]	; (344 <_get_cycles_for_ms+0x18>)
 338:	3002      	adds	r0, #2
 33a:	2103      	movs	r1, #3
 33c:	4798      	blx	r3
 33e:	2364      	movs	r3, #100	; 0x64
 340:	4358      	muls	r0, r3
	return _get_cycles_for_ms_internal(ms, CONF_CPU_FREQUENCY, CPU_FREQ_POWER);
}
 342:	bd10      	pop	{r4, pc}
 344:	00000a6d 	.word	0x00000a6d

00000348 <_delay_init>:
 * \brief Initialize delay functionality
 */
void _delay_init(void *const hw)
{
	(void)hw;
}
 348:	4770      	bx	lr

0000034a <_delay_cycles>:
{
#ifndef _UNIT_TEST_
	(void)hw;
	(void)cycles;
#if defined __GNUC__
	__asm(".syntax unified\n"
 34a:	3901      	subs	r1, #1
 34c:	d8fd      	bhi.n	34a <_delay_cycles>
	__asm("__delay:\n"
	      "subs r1, r1, #1\n"
	      "bhi __delay\n");
#endif
#endif
}
 34e:	4770      	bx	lr

00000350 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
 350:	2800      	cmp	r0, #0
 352:	d100      	bne.n	356 <assert+0x6>
		__asm("BKPT #0");
 354:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
 356:	4770      	bx	lr

00000358 <_sysctrl_init_sources>:
	hri_sysctrl_write_OSC32K_reg(
	    hw,
#if CONF_OSC32K_OVERWRITE_CALIBRATION == 1
	    SYSCTRL_OSC32K_CALIB(CONF_OSC32K_CALIB) |
#else
	    SYSCTRL_OSC32K_CALIB(calib) |
 358:	21fe      	movs	r1, #254	; 0xfe
}

static inline hri_sysctrl_osc32k_reg_t hri_sysctrl_read_OSC32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Sysctrl *)hw)->OSC32K.reg;
 35a:	4b0a      	ldr	r3, [pc, #40]	; (384 <_sysctrl_init_sources+0x2c>)
 35c:	03c9      	lsls	r1, r1, #15
 35e:	699a      	ldr	r2, [r3, #24]
 360:	4011      	ands	r1, r2
#endif
	        (CONF_OSC32K_WRTLOCK << SYSCTRL_OSC32K_WRTLOCK_Pos) | SYSCTRL_OSC32K_STARTUP(CONF_OSC32K_STARTUP)
	        | (CONF_OSC32K_RUNSTDBY << SYSCTRL_OSC32K_RUNSTDBY_Pos) | (CONF_OSC32K_EN1K << SYSCTRL_OSC32K_EN1K_Pos)
	        | (CONF_OSC32K_EN32K << SYSCTRL_OSC32K_EN32K_Pos) | (1 << SYSCTRL_OSC32K_ENABLE_Pos));
 362:	2202      	movs	r2, #2
 364:	430a      	orrs	r2, r1

static inline hri_sysctrl_osculp32k_reg_t hri_sysctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint8_t tmp;
	tmp = ((Sysctrl *)hw)->OSCULP32K.reg;
	tmp = (tmp & SYSCTRL_OSCULP32K_CALIB_Msk) >> SYSCTRL_OSCULP32K_CALIB_Pos;
 366:	211f      	movs	r1, #31
	((Sysctrl *)hw)->OSC32K.reg = data;
 368:	619a      	str	r2, [r3, #24]
	tmp = ((Sysctrl *)hw)->OSCULP32K.reg;
 36a:	7f1a      	ldrb	r2, [r3, #28]
	tmp = (tmp & SYSCTRL_OSCULP32K_CALIB_Msk) >> SYSCTRL_OSCULP32K_CALIB_Pos;
 36c:	400a      	ands	r2, r1
}

static inline void hri_sysctrl_write_OSCULP32K_reg(const void *const hw, hri_sysctrl_osculp32k_reg_t data)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->OSCULP32K.reg = data;
 36e:	771a      	strb	r2, [r3, #28]
#endif
#endif

#if CONF_OSC32K_CONFIG == 1
#if CONF_OSC32K_ENABLE == 1
	while (!hri_sysctrl_get_PCLKSR_OSC32KRDY_bit(hw))
 370:	2204      	movs	r2, #4
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_OSC32KRDY) >> SYSCTRL_PCLKSR_OSC32KRDY_Pos;
 372:	68d9      	ldr	r1, [r3, #12]
 374:	4211      	tst	r1, r2
 376:	d0fc      	beq.n	372 <_sysctrl_init_sources+0x1a>
	((Sysctrl *)hw)->OSC32K.reg |= SYSCTRL_OSC32K_ONDEMAND;
 378:	2280      	movs	r2, #128	; 0x80
 37a:	6999      	ldr	r1, [r3, #24]
 37c:	430a      	orrs	r2, r1
 37e:	619a      	str	r2, [r3, #24]
	hri_sysctrl_set_OSC8M_ONDEMAND_bit(hw);
#endif
#endif

	(void)calib, (void)hw;
}
 380:	4770      	bx	lr
 382:	46c0      	nop			; (mov r8, r8)
 384:	40000800 	.word	0x40000800

00000388 <_sysctrl_init_referenced_generators>:
}

static inline void hri_sysctrl_write_DFLLCTRL_reg(const void *const hw, hri_sysctrl_dfllctrl_reg_t data)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->DFLLCTRL.reg = data;
 388:	2202      	movs	r2, #2
 38a:	4b16      	ldr	r3, [pc, #88]	; (3e4 <_sysctrl_init_referenced_generators+0x5c>)
 38c:	849a      	strh	r2, [r3, #36]	; 0x24
	hri_gclk_write_CLKCTRL_reg(GCLK,
	                           GCLK_CLKCTRL_ID(0) | GCLK_CLKCTRL_GEN(CONF_DFLL_GCLK) | (1 << GCLK_CLKCTRL_CLKEN_Pos));
#endif

	hri_sysctrl_write_DFLLCTRL_reg(hw, SYSCTRL_DFLLCTRL_ENABLE);
	while (!hri_sysctrl_get_PCLKSR_DFLLRDY_bit(hw))
 38e:	320e      	adds	r2, #14
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) >> SYSCTRL_PCLKSR_DFLLRDY_Pos;
 390:	68d9      	ldr	r1, [r3, #12]
 392:	4211      	tst	r1, r2
 394:	d0fc      	beq.n	390 <_sysctrl_init_referenced_generators+0x8>
}

static inline void hri_sysctrl_write_DFLLMUL_reg(const void *const hw, hri_sysctrl_dfllmul_reg_t data)
{
	SYSCTRL_CRITICAL_SECTION_ENTER();
	((Sysctrl *)hw)->DFLLMUL.reg = data;
 396:	4a14      	ldr	r2, [pc, #80]	; (3e8 <_sysctrl_init_referenced_generators+0x60>)
 398:	62da      	str	r2, [r3, #44]	; 0x2c
		;

	hri_sysctrl_write_DFLLMUL_reg(hw,
	                              SYSCTRL_DFLLMUL_CSTEP(CONF_DFLL_CSTEP) | SYSCTRL_DFLLMUL_FSTEP(CONF_DFLL_FSTEP)
	                                  | SYSCTRL_DFLLMUL_MUL(CONF_DFLL_MUL));
	hri_sysctrl_write_DFLLVAL_reg(hw, CONF_DFLLVAL);
 39a:	4a14      	ldr	r2, [pc, #80]	; (3ec <_sysctrl_init_referenced_generators+0x64>)
 39c:	6812      	ldr	r2, [r2, #0]
 39e:	0e92      	lsrs	r2, r2, #26
 3a0:	2a3f      	cmp	r2, #63	; 0x3f
 3a2:	d00f      	beq.n	3c4 <_sysctrl_init_referenced_generators+0x3c>
 3a4:	2180      	movs	r1, #128	; 0x80
 3a6:	0292      	lsls	r2, r2, #10
 3a8:	0089      	lsls	r1, r1, #2
 3aa:	430a      	orrs	r2, r1
	((Sysctrl *)hw)->DFLLVAL.reg = data;
 3ac:	629a      	str	r2, [r3, #40]	; 0x28
	((Sysctrl *)hw)->DFLLCTRL.reg = data;
 3ae:	2202      	movs	r2, #2
 3b0:	849a      	strh	r2, [r3, #36]	; 0x24
	tmp = ((Sysctrl *)hw)->DFLLCTRL.reg;
 3b2:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
	tmp &= mask;
 3b4:	21d0      	movs	r1, #208	; 0xd0
	        | SYSCTRL_DPLLCTRLB_FILTER(CONF_DPLL_FILTER));
#endif

#if CONF_DFLL_CONFIG == 1
#if CONF_DFLL_ENABLE == 1
	if (hri_sysctrl_get_DFLLCTRL_MODE_bit(hw)) {
 3b6:	0752      	lsls	r2, r2, #29
 3b8:	d407      	bmi.n	3ca <_sysctrl_init_referenced_generators+0x42>
#endif

		while (hri_sysctrl_get_PCLKSR_reg(hw, status_mask) != status_mask)
			;
	} else {
		while (!hri_sysctrl_get_PCLKSR_DFLLRDY_bit(hw))
 3ba:	2210      	movs	r2, #16
	return (((Sysctrl *)hw)->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY) >> SYSCTRL_PCLKSR_DFLLRDY_Pos;
 3bc:	68d9      	ldr	r1, [r3, #12]
 3be:	4211      	tst	r1, r2
 3c0:	d0fc      	beq.n	3bc <_sysctrl_init_referenced_generators+0x34>
 3c2:	e006      	b.n	3d2 <_sysctrl_init_referenced_generators+0x4a>
	hri_sysctrl_write_DFLLVAL_reg(hw, CONF_DFLLVAL);
 3c4:	22fc      	movs	r2, #252	; 0xfc
 3c6:	01d2      	lsls	r2, r2, #7
 3c8:	e7f0      	b.n	3ac <_sysctrl_init_referenced_generators+0x24>
	tmp = ((Sysctrl *)hw)->PCLKSR.reg;
 3ca:	68da      	ldr	r2, [r3, #12]
	tmp &= mask;
 3cc:	400a      	ands	r2, r1
		while (hri_sysctrl_get_PCLKSR_reg(hw, status_mask) != status_mask)
 3ce:	2ad0      	cmp	r2, #208	; 0xd0
 3d0:	d1fb      	bne.n	3ca <_sysctrl_init_referenced_generators+0x42>
	((Sysctrl *)hw)->DFLLCTRL.reg |= SYSCTRL_DFLLCTRL_ONDEMAND;
 3d2:	2280      	movs	r2, #128	; 0x80
 3d4:	8c99      	ldrh	r1, [r3, #36]	; 0x24
 3d6:	430a      	orrs	r2, r1
 3d8:	849a      	strh	r2, [r3, #36]	; 0x24
	return ((const Gclk *)hw)->STATUS.bit.SYNCBUSY;
}

static inline bool hri_gclk_get_STATUS_SYNCBUSY_bit(const void *const hw)
{
	return (((Gclk *)hw)->STATUS.reg & GCLK_STATUS_SYNCBUSY) >> GCLK_STATUS_SYNCBUSY_Pos;
 3da:	4a05      	ldr	r2, [pc, #20]	; (3f0 <_sysctrl_init_referenced_generators+0x68>)
 3dc:	7853      	ldrb	r3, [r2, #1]
 3de:	09db      	lsrs	r3, r3, #7
	hri_sysctrl_set_DPLLCTRLA_ONDEMAND_bit(hw);
#endif
#endif

#if CONF_DFLL_CONFIG == 1
	while (hri_gclk_get_STATUS_SYNCBUSY_bit(GCLK))
 3e0:	d1fc      	bne.n	3dc <_sysctrl_init_referenced_generators+0x54>
	/* Disable after all possible configurations needs sync written. */
	hri_sysctrl_clear_OSC32K_ENABLE_bit(hw);
#endif

	(void)hw;
}
 3e2:	4770      	bx	lr
 3e4:	40000800 	.word	0x40000800
 3e8:	04010000 	.word	0x04010000
 3ec:	00806024 	.word	0x00806024
 3f0:	40000c00 	.word	0x40000c00

000003f4 <_gclk_init_generators_by_fref>:

void _gclk_init_generators_by_fref(uint32_t bm)
{

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
 3f4:	07c3      	lsls	r3, r0, #31
 3f6:	d508      	bpl.n	40a <_gclk_init_generators_by_fref+0x16>
}

static inline void hri_gclk_write_GENDIV_reg(const void *const hw, hri_gclk_gendiv_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->GENDIV.reg = data;
 3f8:	2280      	movs	r2, #128	; 0x80
 3fa:	4b0a      	ldr	r3, [pc, #40]	; (424 <_gclk_init_generators_by_fref+0x30>)
 3fc:	0052      	lsls	r2, r2, #1
 3fe:	609a      	str	r2, [r3, #8]
	((Gclk *)hw)->GENCTRL.reg = data;
 400:	4a09      	ldr	r2, [pc, #36]	; (428 <_gclk_init_generators_by_fref+0x34>)
 402:	605a      	str	r2, [r3, #4]
	while (((const Gclk *)hw)->STATUS.bit.SYNCBUSY)
 404:	785a      	ldrb	r2, [r3, #1]
 406:	09d2      	lsrs	r2, r2, #7
 408:	d1fc      	bne.n	404 <_gclk_init_generators_by_fref+0x10>
		        | (CONF_GCLK_GENERATOR_2_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_2_SRC | GCLK_GENCTRL_ID(2));
	}
#endif

#if CONF_GCLK_GENERATOR_3_CONFIG == 1
	if (bm & (1ul << 3)) {
 40a:	0703      	lsls	r3, r0, #28
 40c:	d508      	bpl.n	420 <_gclk_init_generators_by_fref+0x2c>
	((Gclk *)hw)->GENDIV.reg = data;
 40e:	2204      	movs	r2, #4
 410:	4b04      	ldr	r3, [pc, #16]	; (424 <_gclk_init_generators_by_fref+0x30>)
 412:	32ff      	adds	r2, #255	; 0xff
 414:	609a      	str	r2, [r3, #8]
	((Gclk *)hw)->GENCTRL.reg = data;
 416:	4a05      	ldr	r2, [pc, #20]	; (42c <_gclk_init_generators_by_fref+0x38>)
 418:	605a      	str	r2, [r3, #4]
	while (((const Gclk *)hw)->STATUS.bit.SYNCBUSY)
 41a:	785a      	ldrb	r2, [r3, #1]
 41c:	09d2      	lsrs	r2, r2, #7
 41e:	d1fc      	bne.n	41a <_gclk_init_generators_by_fref+0x26>
		        | (CONF_GCLK_GEN_8_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_8_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_8_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_8_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_8_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_8_SRC | GCLK_GENCTRL_ID(8));
	}
#endif
}
 420:	4770      	bx	lr
 422:	46c0      	nop			; (mov r8, r8)
 424:	40000c00 	.word	0x40000c00
 428:	00010700 	.word	0x00010700
 42c:	00010403 	.word	0x00010403

00000430 <main>:
#include <atmel_start.h>

int main(void)
{
 430:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
 432:	4b10      	ldr	r3, [pc, #64]	; (474 <main+0x44>)
 434:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = PORT_OUT_OUT(mask);
}

static inline void hri_port_set_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
 436:	24c0      	movs	r4, #192	; 0xc0

	delay_init(SysTick);
 438:	480f      	ldr	r0, [pc, #60]	; (478 <main+0x48>)
 43a:	4b10      	ldr	r3, [pc, #64]	; (47c <main+0x4c>)
 43c:	4798      	blx	r3
 43e:	05e4      	lsls	r4, r4, #23
 440:	2380      	movs	r3, #128	; 0x80
 442:	2280      	movs	r2, #128	; 0x80
 444:	2701      	movs	r7, #1
 446:	2602      	movs	r6, #2
	while (1) {
			gpio_set_pin_level(GreenLED, true);
			gpio_set_pin_level(YellowLED, true);
			gpio_set_pin_level(PA10, true);
			gpio_set_pin_level(GPIO(GPIO_PORTA, 11), true);
			delay_ms(500);
 448:	20fa      	movs	r0, #250	; 0xfa
 44a:	00db      	lsls	r3, r3, #3
 44c:	0112      	lsls	r2, r2, #4
 44e:	61a7      	str	r7, [r4, #24]
 450:	0040      	lsls	r0, r0, #1
 452:	61a6      	str	r6, [r4, #24]
 454:	4d0a      	ldr	r5, [pc, #40]	; (480 <main+0x50>)
 456:	61a3      	str	r3, [r4, #24]
 458:	61a2      	str	r2, [r4, #24]
 45a:	47a8      	blx	r5
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = ~data;
}

static inline void hri_port_clear_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
 45c:	2380      	movs	r3, #128	; 0x80
 45e:	2280      	movs	r2, #128	; 0x80
			gpio_set_pin_level(GreenLED, false);
			gpio_set_pin_level(YellowLED, false);
			gpio_set_pin_level(PA10, false);
			gpio_set_pin_level(GPIO(GPIO_PORTA, 11), false);
			delay_ms(500);
 460:	20fa      	movs	r0, #250	; 0xfa
 462:	00db      	lsls	r3, r3, #3
 464:	0112      	lsls	r2, r2, #4
 466:	6167      	str	r7, [r4, #20]
 468:	0040      	lsls	r0, r0, #1
 46a:	6166      	str	r6, [r4, #20]
 46c:	6163      	str	r3, [r4, #20]
 46e:	6162      	str	r2, [r4, #20]
 470:	47a8      	blx	r5
 472:	e7e5      	b.n	440 <main+0x10>
 474:	00000a61 	.word	0x00000a61
 478:	e000e010 	.word	0xe000e010
 47c:	000002a5 	.word	0x000002a5
 480:	000002b9 	.word	0x000002b9

00000484 <_gpio_set_direction.constprop.7>:
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
 484:	23c0      	movs	r3, #192	; 0xc0
 486:	05db      	lsls	r3, r3, #23
 488:	6098      	str	r0, [r3, #8]
		                                | ((mask & 0xffff0000) >> 16));
		break;

	case GPIO_DIRECTION_OUT:
		hri_port_set_DIR_reg(PORT_IOBUS, port, mask);
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
 48a:	2380      	movs	r3, #128	; 0x80
 48c:	b282      	uxth	r2, r0
 48e:	05db      	lsls	r3, r3, #23
 490:	4313      	orrs	r3, r2

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
 492:	4a04      	ldr	r2, [pc, #16]	; (4a4 <_gpio_set_direction.constprop.7+0x20>)
		hri_port_write_WRCONFIG_reg(
		    PORT, port, PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | ((mask & 0xffff0000) >> 16));
 494:	0c00      	lsrs	r0, r0, #16
 496:	6293      	str	r3, [r2, #40]	; 0x28
		hri_port_write_WRCONFIG_reg(
 498:	23c0      	movs	r3, #192	; 0xc0
 49a:	061b      	lsls	r3, r3, #24
 49c:	4318      	orrs	r0, r3
 49e:	6290      	str	r0, [r2, #40]	; 0x28
		break;

	default:
		ASSERT(false);
	}
}
 4a0:	4770      	bx	lr
 4a2:	46c0      	nop			; (mov r8, r8)
 4a4:	41004400 	.word	0x41004400

000004a8 <I2C_0_PORT_init>:
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
 4a8:	4b11      	ldr	r3, [pc, #68]	; (4f0 <I2C_0_PORT_init+0x48>)
struct i2c_m_sync_desc I2C_0;

struct pwm_descriptor PWM_0;

void I2C_0_PORT_init(void)
{
 4aa:	b570      	push	{r4, r5, r6, lr}
 4ac:	0018      	movs	r0, r3
 4ae:	2504      	movs	r5, #4
 4b0:	3048      	adds	r0, #72	; 0x48
 4b2:	7802      	ldrb	r2, [r0, #0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
 4b4:	240f      	movs	r4, #15
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
 4b6:	43aa      	bics	r2, r5
 4b8:	7002      	strb	r2, [r0, #0]
	tmp &= ~PORT_PINCFG_PMUXEN;
 4ba:	2201      	movs	r2, #1
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
 4bc:	7801      	ldrb	r1, [r0, #0]
	tmp &= ~PORT_PINCFG_PMUXEN;
 4be:	4391      	bics	r1, r2
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
 4c0:	4311      	orrs	r1, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
 4c2:	7001      	strb	r1, [r0, #0]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
 4c4:	0019      	movs	r1, r3
	tmp |= PORT_PMUX_PMUXE(data);
 4c6:	2003      	movs	r0, #3
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
 4c8:	3134      	adds	r1, #52	; 0x34
 4ca:	780e      	ldrb	r6, [r1, #0]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
 4cc:	3349      	adds	r3, #73	; 0x49
	tmp &= ~PORT_PMUX_PMUXE_Msk;
 4ce:	43a6      	bics	r6, r4
	tmp |= PORT_PMUX_PMUXE(data);
 4d0:	4330      	orrs	r0, r6
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
 4d2:	7008      	strb	r0, [r1, #0]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
 4d4:	7818      	ldrb	r0, [r3, #0]
 4d6:	43a8      	bics	r0, r5
 4d8:	7018      	strb	r0, [r3, #0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
 4da:	7818      	ldrb	r0, [r3, #0]
	tmp &= ~PORT_PINCFG_PMUXEN;
 4dc:	4390      	bics	r0, r2
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
 4de:	4302      	orrs	r2, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
 4e0:	701a      	strb	r2, [r3, #0]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
 4e2:	780b      	ldrb	r3, [r1, #0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
 4e4:	401c      	ands	r4, r3
	tmp |= PORT_PMUX_PMUXO(data);
 4e6:	2330      	movs	r3, #48	; 0x30
 4e8:	4323      	orrs	r3, r4
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
 4ea:	700b      	strb	r3, [r1, #0]
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PA09, PINMUX_PA09D_SERCOM2_PAD1);
}
 4ec:	bd70      	pop	{r4, r5, r6, pc}
 4ee:	46c0      	nop			; (mov r8, r8)
 4f0:	41004400 	.word	0x41004400

000004f4 <I2C_0_CLOCK_init>:
			peripheral = (uint32_t)_pm_get_apbb_index(module);
			PM->APBBMASK.reg |= 1 << peripheral;
		}
		break;
	case PM_BUS_APBC:
		PM->APBCMASK.reg |= 1 << peripheral;
 4f4:	2310      	movs	r3, #16
 4f6:	4a05      	ldr	r2, [pc, #20]	; (50c <I2C_0_CLOCK_init+0x18>)
 4f8:	6a11      	ldr	r1, [r2, #32]
 4fa:	430b      	orrs	r3, r1
 4fc:	6213      	str	r3, [r2, #32]
	((Gclk *)hw)->CLKCTRL.reg = data;
 4fe:	4b04      	ldr	r3, [pc, #16]	; (510 <I2C_0_CLOCK_init+0x1c>)
 500:	4a04      	ldr	r2, [pc, #16]	; (514 <I2C_0_CLOCK_init+0x20>)
 502:	805a      	strh	r2, [r3, #2]
 504:	4a04      	ldr	r2, [pc, #16]	; (518 <I2C_0_CLOCK_init+0x24>)
 506:	805a      	strh	r2, [r3, #2]
void I2C_0_CLOCK_init(void)
{
	_pm_enable_bus_clock(PM_BUS_APBC, SERCOM2);
	_gclk_enable_channel(SERCOM2_GCLK_ID_CORE, CONF_GCLK_SERCOM2_CORE_SRC);
	_gclk_enable_channel(SERCOM2_GCLK_ID_SLOW, CONF_GCLK_SERCOM2_SLOW_SRC);
}
 508:	4770      	bx	lr
 50a:	46c0      	nop			; (mov r8, r8)
 50c:	40000400 	.word	0x40000400
 510:	40000c00 	.word	0x40000c00
 514:	00004016 	.word	0x00004016
 518:	00004313 	.word	0x00004313

0000051c <I2C_0_init>:

void I2C_0_init(void)
{
 51c:	b510      	push	{r4, lr}
	I2C_0_CLOCK_init();
 51e:	4b04      	ldr	r3, [pc, #16]	; (530 <I2C_0_init+0x14>)
 520:	4798      	blx	r3
	i2c_m_sync_init(&I2C_0, SERCOM2);
 522:	4904      	ldr	r1, [pc, #16]	; (534 <I2C_0_init+0x18>)
 524:	4b04      	ldr	r3, [pc, #16]	; (538 <I2C_0_init+0x1c>)
 526:	4805      	ldr	r0, [pc, #20]	; (53c <I2C_0_init+0x20>)
 528:	4798      	blx	r3
	I2C_0_PORT_init();
 52a:	4b05      	ldr	r3, [pc, #20]	; (540 <I2C_0_init+0x24>)
 52c:	4798      	blx	r3
}
 52e:	bd10      	pop	{r4, pc}
 530:	000004f5 	.word	0x000004f5
 534:	42001000 	.word	0x42001000
 538:	00000265 	.word	0x00000265
 53c:	20000040 	.word	0x20000040
 540:	000004a9 	.word	0x000004a9

00000544 <system_init>:
	PWM_0_PORT_init();
	pwm_init(&PWM_0, TCC1, _tcc_get_pwm());
}

void system_init(void)
{
 544:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
 546:	27c0      	movs	r7, #192	; 0xc0
 548:	2501      	movs	r5, #1
 54a:	05ff      	lsls	r7, r7, #23
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
 54c:	4c13      	ldr	r4, [pc, #76]	; (59c <system_init+0x58>)
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
 54e:	4b14      	ldr	r3, [pc, #80]	; (5a0 <system_init+0x5c>)
 550:	4798      	blx	r3
 *                      GPIO_DIRECTION_OFF = Disables the pin
 *                      (low power state)
 */
static inline void gpio_set_pin_direction(const uint8_t pin, const enum gpio_direction direction)
{
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
 552:	4e14      	ldr	r6, [pc, #80]	; (5a4 <system_init+0x60>)
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
 554:	617d      	str	r5, [r7, #20]
 556:	0028      	movs	r0, r5
 558:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
 55a:	0022      	movs	r2, r4
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
 55c:	2002      	movs	r0, #2
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
 55e:	3240      	adds	r2, #64	; 0x40
 560:	7813      	ldrb	r3, [r2, #0]
	tmp &= ~PORT_PINCFG_PMUXEN;
 562:	43ab      	bics	r3, r5
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
 564:	7013      	strb	r3, [r2, #0]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
 566:	6178      	str	r0, [r7, #20]
 568:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
 56a:	0022      	movs	r2, r4
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
 56c:	2080      	movs	r0, #128	; 0x80
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
 56e:	3241      	adds	r2, #65	; 0x41
 570:	7813      	ldrb	r3, [r2, #0]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
 572:	00c0      	lsls	r0, r0, #3
	tmp &= ~PORT_PINCFG_PMUXEN;
 574:	43ab      	bics	r3, r5
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
 576:	7013      	strb	r3, [r2, #0]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
 578:	6178      	str	r0, [r7, #20]
 57a:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
 57c:	0022      	movs	r2, r4
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
 57e:	2080      	movs	r0, #128	; 0x80
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
 580:	324a      	adds	r2, #74	; 0x4a
 582:	7813      	ldrb	r3, [r2, #0]
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
 584:	0100      	lsls	r0, r0, #4
	tmp &= ~PORT_PINCFG_PMUXEN;
 586:	43ab      	bics	r3, r5
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
 588:	7013      	strb	r3, [r2, #0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
 58a:	344b      	adds	r4, #75	; 0x4b
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
 58c:	6178      	str	r0, [r7, #20]
 58e:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
 590:	7823      	ldrb	r3, [r4, #0]
	tmp &= ~PORT_PINCFG_PMUXEN;
 592:	43ab      	bics	r3, r5
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
 594:	7023      	strb	r3, [r4, #0]
	gpio_set_pin_direction(GPIO(GPIO_PORTA, 11), GPIO_DIRECTION_OUT);
	gpio_set_pin_function(GPIO(GPIO_PORTA, 11), GPIO_PIN_FUNCTION_OFF);

	//PWM_0_init();

	I2C_0_init();
 596:	4b04      	ldr	r3, [pc, #16]	; (5a8 <system_init+0x64>)
 598:	4798      	blx	r3
}
 59a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 59c:	41004400 	.word	0x41004400
 5a0:	000002f9 	.word	0x000002f9
 5a4:	00000485 	.word	0x00000485
 5a8:	0000051d 	.word	0x0000051d

000005ac <hri_sercomi2cm_wait_for_sync>:
typedef uint8_t  hri_sercomusart_intflag_reg_t;
typedef uint8_t  hri_sercomusart_rxpl_reg_t;

static inline void hri_sercomi2cm_wait_for_sync(const void *const hw, hri_sercomi2cm_syncbusy_reg_t reg)
{
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
 5ac:	69c3      	ldr	r3, [r0, #28]
 5ae:	4219      	tst	r1, r3
 5b0:	d1fc      	bne.n	5ac <hri_sercomi2cm_wait_for_sync>
	};
}
 5b2:	4770      	bx	lr

000005b4 <hri_sercomi2cm_clear_CTRLA_ENABLE_bit>:
}

static inline void hri_sercomi2cm_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE;
 5b4:	2202      	movs	r2, #2
{
 5b6:	b510      	push	{r4, lr}
	((Sercom *)hw)->I2CM.CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE;
 5b8:	6803      	ldr	r3, [r0, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
 5ba:	2103      	movs	r1, #3
	((Sercom *)hw)->I2CM.CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE;
 5bc:	4393      	bics	r3, r2
 5be:	6003      	str	r3, [r0, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
 5c0:	4b01      	ldr	r3, [pc, #4]	; (5c8 <hri_sercomi2cm_clear_CTRLA_ENABLE_bit+0x14>)
 5c2:	4798      	blx	r3
	SERCOM_CRITICAL_SECTION_LEAVE();
}
 5c4:	bd10      	pop	{r4, pc}
 5c6:	46c0      	nop			; (mov r8, r8)
 5c8:	000005ad 	.word	0x000005ad

000005cc <_get_i2cm_index>:
{
#ifdef _UNIT_TEST_
	return ((uint32_t)hw - (uint32_t)SERCOM0) / sizeof(Sercom);
#endif

	return ((uint32_t)hw - (uint32_t)SERCOM0) >> 10;
 5cc:	4b07      	ldr	r3, [pc, #28]	; (5ec <_get_i2cm_index+0x20>)
 * \param[in] hw The pointer to hardware instance

 * \return The ordinal number of the given sercom hardware instance
 */
static int8_t _get_i2cm_index(const void *const hw)
{
 5ce:	b510      	push	{r4, lr}
	return ((uint32_t)hw - (uint32_t)SERCOM0) >> 10;
 5d0:	18c3      	adds	r3, r0, r3
 5d2:	0a9b      	lsrs	r3, r3, #10
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_i2cms); i++) {
		if (_i2cms[i].number == sercom_offset) {
 5d4:	b2db      	uxtb	r3, r3
			return i;
 5d6:	2000      	movs	r0, #0
		if (_i2cms[i].number == sercom_offset) {
 5d8:	2b02      	cmp	r3, #2
 5da:	d006      	beq.n	5ea <_get_i2cm_index+0x1e>
		}
	}

	ASSERT(false);
 5dc:	22e6      	movs	r2, #230	; 0xe6
 5de:	4904      	ldr	r1, [pc, #16]	; (5f0 <_get_i2cm_index+0x24>)
 5e0:	0092      	lsls	r2, r2, #2
 5e2:	4b04      	ldr	r3, [pc, #16]	; (5f4 <_get_i2cm_index+0x28>)
 5e4:	4798      	blx	r3
	return -1;
 5e6:	2001      	movs	r0, #1
 5e8:	4240      	negs	r0, r0
}
 5ea:	bd10      	pop	{r4, pc}
 5ec:	bdfff800 	.word	0xbdfff800
 5f0:	00000c11 	.word	0x00000c11
 5f4:	00000351 	.word	0x00000351

000005f8 <_sercom_i2c_send_stop>:
}

static inline void hri_sercomi2cm_set_CTRLB_CMD_bf(const void *const hw, hri_sercomi2cm_ctrlb_reg_t mask)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
 5f8:	23c0      	movs	r3, #192	; 0xc0

static inline void _sercom_i2c_send_stop(void *const hw)
{
 5fa:	b510      	push	{r4, lr}
 5fc:	6842      	ldr	r2, [r0, #4]
 5fe:	029b      	lsls	r3, r3, #10
 600:	4313      	orrs	r3, r2
 602:	6043      	str	r3, [r0, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
 604:	2104      	movs	r1, #4
 606:	4b01      	ldr	r3, [pc, #4]	; (60c <_sercom_i2c_send_stop+0x14>)
 608:	4798      	blx	r3
	hri_sercomi2cm_set_CTRLB_CMD_bf(hw, CMD_STOP);
}
 60a:	bd10      	pop	{r4, pc}
 60c:	000005ad 	.word	0x000005ad

00000610 <_sercom_i2c_sync_analyse_flags>:

/**
 * \brief SERCOM I2CM analyze hardware status and transfer next byte
 */
static inline int32_t _sercom_i2c_sync_analyse_flags(void *const hw, uint32_t flags, struct _i2c_m_msg *const msg)
{
 610:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
 612:	6803      	ldr	r3, [r0, #0]
 614:	0005      	movs	r5, r0
 616:	9100      	str	r1, [sp, #0]
	((Sercom *)hw)->I2CM.STATUS.reg |= mask;
}

static inline hri_sercomi2cm_status_reg_t hri_sercomi2cm_read_STATUS_reg(const void *const hw)
{
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
 618:	4f5b      	ldr	r7, [pc, #364]	; (788 <_sercom_i2c_sync_analyse_flags+0x178>)
 61a:	2104      	movs	r1, #4
 61c:	0014      	movs	r4, r2
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
 61e:	9301      	str	r3, [sp, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
 620:	47b8      	blx	r7
	int      sclsm  = hri_sercomi2cm_get_CTRLA_SCLSM_bit(hw);
	uint16_t status = hri_sercomi2cm_read_STATUS_reg(hw);

	if (flags & MB_FLAG) {
 622:	2101      	movs	r1, #1
	return ((Sercom *)hw)->I2CM.STATUS.reg;
 624:	8b6b      	ldrh	r3, [r5, #26]
 626:	9e00      	ldr	r6, [sp, #0]
 628:	b29b      	uxth	r3, r3
 62a:	400e      	ands	r6, r1
 62c:	2202      	movs	r2, #2
 62e:	2e00      	cmp	r6, #0
 630:	d100      	bne.n	634 <_sercom_i2c_sync_analyse_flags+0x24>
 632:	e066      	b.n	702 <_sercom_i2c_sync_analyse_flags+0xf2>
		/* tx error */
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
 634:	4213      	tst	r3, r2
 636:	d00f      	beq.n	658 <_sercom_i2c_sync_analyse_flags+0x48>
			hri_sercomi2cm_clear_interrupt_MB_bit(hw);
			msg->flags |= I2C_M_FAIL;
 638:	2280      	movs	r2, #128	; 0x80
			msg->flags &= ~I2C_M_BUSY;

			if (status & SERCOM_I2CM_STATUS_BUSERR) {
 63a:	400b      	ands	r3, r1
				return I2C_ERR_BUS;
			}

			return I2C_ERR_BAD_ADDRESS;
 63c:	425e      	negs	r6, r3
 63e:	415e      	adcs	r6, r3
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
 640:	7629      	strb	r1, [r5, #24]
			msg->flags |= I2C_M_FAIL;
 642:	8860      	ldrh	r0, [r4, #2]
 644:	0152      	lsls	r2, r2, #5
 646:	4302      	orrs	r2, r0
 648:	8062      	strh	r2, [r4, #2]
			msg->flags &= ~I2C_M_BUSY;
 64a:	8862      	ldrh	r2, [r4, #2]
 64c:	484f      	ldr	r0, [pc, #316]	; (78c <_sercom_i2c_sync_analyse_flags+0x17c>)
			return I2C_ERR_BAD_ADDRESS;
 64e:	3e05      	subs	r6, #5
			msg->flags &= ~I2C_M_BUSY;
 650:	4002      	ands	r2, r0
 652:	8062      	strh	r2, [r4, #2]

		hri_sercomi2cm_clear_interrupt_SB_bit(hw);
	}

	return I2C_OK;
}
 654:	0030      	movs	r0, r6
 656:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
 658:	2604      	movs	r6, #4
 65a:	401e      	ands	r6, r3
 65c:	d015      	beq.n	68a <_sercom_i2c_sync_analyse_flags+0x7a>
				if (msg->len > 0) {
 65e:	6863      	ldr	r3, [r4, #4]
 660:	2b00      	cmp	r3, #0
 662:	dd04      	ble.n	66e <_sercom_i2c_sync_analyse_flags+0x5e>
					msg->flags |= I2C_M_FAIL;
 664:	2380      	movs	r3, #128	; 0x80
 666:	8862      	ldrh	r2, [r4, #2]
 668:	015b      	lsls	r3, r3, #5
 66a:	4313      	orrs	r3, r2
 66c:	8063      	strh	r3, [r4, #2]
				if (msg->flags & I2C_M_STOP) {
 66e:	8863      	ldrh	r3, [r4, #2]
 670:	b21b      	sxth	r3, r3
 672:	2b00      	cmp	r3, #0
 674:	da02      	bge.n	67c <_sercom_i2c_sync_analyse_flags+0x6c>
					_sercom_i2c_send_stop(hw);
 676:	0028      	movs	r0, r5
 678:	4b45      	ldr	r3, [pc, #276]	; (790 <_sercom_i2c_sync_analyse_flags+0x180>)
 67a:	4798      	blx	r3
				msg->flags &= ~I2C_M_BUSY;
 67c:	8863      	ldrh	r3, [r4, #2]
 67e:	4a43      	ldr	r2, [pc, #268]	; (78c <_sercom_i2c_sync_analyse_flags+0x17c>)
 680:	4013      	ands	r3, r2
 682:	8063      	strh	r3, [r4, #2]
			return I2C_NACK;
 684:	2602      	movs	r6, #2
 686:	4276      	negs	r6, r6
 688:	e7e4      	b.n	654 <_sercom_i2c_sync_analyse_flags+0x44>
			if (msg->flags & I2C_M_TEN) {
 68a:	2380      	movs	r3, #128	; 0x80
 68c:	8862      	ldrh	r2, [r4, #2]
 68e:	00db      	lsls	r3, r3, #3
 690:	401a      	ands	r2, r3
 692:	9200      	str	r2, [sp, #0]
 694:	d018      	beq.n	6c8 <_sercom_i2c_sync_analyse_flags+0xb8>
				                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
 696:	2206      	movs	r2, #6
				                              ((((msg->addr & TEN_ADDR_MASK) >> 8) | TEN_ADDR_FRAME) << 1) | I2C_M_RD
 698:	8823      	ldrh	r3, [r4, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
 69a:	2104      	movs	r1, #4
 69c:	09db      	lsrs	r3, r3, #7
				                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
 69e:	4013      	ands	r3, r2
 6a0:	0028      	movs	r0, r5
 6a2:	9300      	str	r3, [sp, #0]
 6a4:	47b8      	blx	r7
 6a6:	2280      	movs	r2, #128	; 0x80
	return ((Sercom *)hw)->I2CM.ADDR.reg;
 6a8:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 6aa:	01d2      	lsls	r2, r2, #7
 6ac:	401a      	ands	r2, r3
				hri_sercomi2cm_write_ADDR_reg(hw,
 6ae:	23f1      	movs	r3, #241	; 0xf1
 6b0:	4313      	orrs	r3, r2
 6b2:	9a00      	ldr	r2, [sp, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
 6b4:	2104      	movs	r1, #4
 6b6:	4313      	orrs	r3, r2
	((Sercom *)hw)->I2CM.ADDR.reg = data;
 6b8:	626b      	str	r3, [r5, #36]	; 0x24
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
 6ba:	0028      	movs	r0, r5
 6bc:	47b8      	blx	r7
				msg->flags &= ~I2C_M_TEN;
 6be:	8863      	ldrh	r3, [r4, #2]
 6c0:	4a34      	ldr	r2, [pc, #208]	; (794 <_sercom_i2c_sync_analyse_flags+0x184>)
				msg->flags &= ~I2C_M_BUSY;
 6c2:	4013      	ands	r3, r2
 6c4:	8063      	strh	r3, [r4, #2]
 6c6:	e7c5      	b.n	654 <_sercom_i2c_sync_analyse_flags+0x44>
			if (msg->len == 0) {
 6c8:	6866      	ldr	r6, [r4, #4]
 6ca:	2e00      	cmp	r6, #0
 6cc:	d109      	bne.n	6e2 <_sercom_i2c_sync_analyse_flags+0xd2>
				if (msg->flags & I2C_M_STOP) {
 6ce:	8863      	ldrh	r3, [r4, #2]
 6d0:	b21b      	sxth	r3, r3
 6d2:	2b00      	cmp	r3, #0
 6d4:	da02      	bge.n	6dc <_sercom_i2c_sync_analyse_flags+0xcc>
					_sercom_i2c_send_stop(hw);
 6d6:	0028      	movs	r0, r5
 6d8:	4b2d      	ldr	r3, [pc, #180]	; (790 <_sercom_i2c_sync_analyse_flags+0x180>)
 6da:	4798      	blx	r3
				msg->flags &= ~I2C_M_BUSY;
 6dc:	8863      	ldrh	r3, [r4, #2]
 6de:	4a2b      	ldr	r2, [pc, #172]	; (78c <_sercom_i2c_sync_analyse_flags+0x17c>)
 6e0:	e7ef      	b.n	6c2 <_sercom_i2c_sync_analyse_flags+0xb2>
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
 6e2:	68a3      	ldr	r3, [r4, #8]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
 6e4:	2104      	movs	r1, #4
 6e6:	781a      	ldrb	r2, [r3, #0]
	((Sercom *)hw)->I2CM.DATA.reg = data;
 6e8:	002b      	movs	r3, r5
 6ea:	3328      	adds	r3, #40	; 0x28
 6ec:	701a      	strb	r2, [r3, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
 6ee:	0028      	movs	r0, r5
 6f0:	47b8      	blx	r7
				msg->buffer++;
 6f2:	68a3      	ldr	r3, [r4, #8]
 6f4:	3301      	adds	r3, #1
 6f6:	60a3      	str	r3, [r4, #8]
				msg->len--;
 6f8:	6863      	ldr	r3, [r4, #4]
 6fa:	3b01      	subs	r3, #1
 6fc:	6063      	str	r3, [r4, #4]
	return I2C_OK;
 6fe:	2600      	movs	r6, #0
 700:	e7a8      	b.n	654 <_sercom_i2c_sync_analyse_flags+0x44>
	} else if (flags & SB_FLAG) {
 702:	9800      	ldr	r0, [sp, #0]
 704:	4210      	tst	r0, r2
 706:	d0a5      	beq.n	654 <_sercom_i2c_sync_analyse_flags+0x44>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
 708:	6862      	ldr	r2, [r4, #4]
 70a:	2a00      	cmp	r2, #0
 70c:	d038      	beq.n	780 <_sercom_i2c_sync_analyse_flags+0x170>
 70e:	075b      	lsls	r3, r3, #29
 710:	d436      	bmi.n	780 <_sercom_i2c_sync_analyse_flags+0x170>
	tmp = (tmp & SERCOM_I2CM_CTRLA_SCLSM) >> SERCOM_I2CM_CTRLA_SCLSM_Pos;
 712:	9b01      	ldr	r3, [sp, #4]
			msg->len--;
 714:	3a01      	subs	r2, #1
 716:	0ede      	lsrs	r6, r3, #27
 718:	400e      	ands	r6, r1
 71a:	6062      	str	r2, [r4, #4]
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
 71c:	2a00      	cmp	r2, #0
 71e:	d10a      	bne.n	736 <_sercom_i2c_sync_analyse_flags+0x126>
 720:	2e00      	cmp	r6, #0
 722:	d10c      	bne.n	73e <_sercom_i2c_sync_analyse_flags+0x12e>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
 724:	2380      	movs	r3, #128	; 0x80
 726:	686a      	ldr	r2, [r5, #4]
 728:	02db      	lsls	r3, r3, #11
 72a:	4313      	orrs	r3, r2
 72c:	606b      	str	r3, [r5, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
 72e:	2104      	movs	r1, #4
 730:	0028      	movs	r0, r5
 732:	47b8      	blx	r7
 734:	e003      	b.n	73e <_sercom_i2c_sync_analyse_flags+0x12e>
 736:	2a01      	cmp	r2, #1
 738:	d101      	bne.n	73e <_sercom_i2c_sync_analyse_flags+0x12e>
 73a:	2e00      	cmp	r6, #0
 73c:	d1f2      	bne.n	724 <_sercom_i2c_sync_analyse_flags+0x114>
			if (msg->len == 0) {
 73e:	6863      	ldr	r3, [r4, #4]
 740:	2b00      	cmp	r3, #0
 742:	d110      	bne.n	766 <_sercom_i2c_sync_analyse_flags+0x156>
				if (msg->flags & I2C_M_STOP) {
 744:	8863      	ldrh	r3, [r4, #2]
 746:	4e11      	ldr	r6, [pc, #68]	; (78c <_sercom_i2c_sync_analyse_flags+0x17c>)
 748:	b21b      	sxth	r3, r3
 74a:	2b00      	cmp	r3, #0
 74c:	da08      	bge.n	760 <_sercom_i2c_sync_analyse_flags+0x150>
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
 74e:	686b      	ldr	r3, [r5, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
 750:	0028      	movs	r0, r5
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
 752:	4033      	ands	r3, r6
 754:	606b      	str	r3, [r5, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
 756:	2104      	movs	r1, #4
 758:	47b8      	blx	r7
					_sercom_i2c_send_stop(hw);
 75a:	0028      	movs	r0, r5
 75c:	4b0c      	ldr	r3, [pc, #48]	; (790 <_sercom_i2c_sync_analyse_flags+0x180>)
 75e:	4798      	blx	r3
				msg->flags &= ~I2C_M_BUSY;
 760:	8863      	ldrh	r3, [r4, #2]
 762:	4033      	ands	r3, r6
 764:	8063      	strh	r3, [r4, #2]
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
 766:	68a6      	ldr	r6, [r4, #8]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
 768:	2104      	movs	r1, #4
 76a:	1c73      	adds	r3, r6, #1
 76c:	60a3      	str	r3, [r4, #8]
 76e:	0028      	movs	r0, r5
 770:	47b8      	blx	r7
	return ((Sercom *)hw)->I2CM.DATA.reg;
 772:	002b      	movs	r3, r5
 774:	3328      	adds	r3, #40	; 0x28
 776:	781b      	ldrb	r3, [r3, #0]
 778:	7033      	strb	r3, [r6, #0]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
 77a:	2302      	movs	r3, #2
 77c:	762b      	strb	r3, [r5, #24]
 77e:	e7be      	b.n	6fe <_sercom_i2c_sync_analyse_flags+0xee>
 780:	2302      	movs	r3, #2
 782:	762b      	strb	r3, [r5, #24]
 784:	e77e      	b.n	684 <_sercom_i2c_sync_analyse_flags+0x74>
 786:	46c0      	nop			; (mov r8, r8)
 788:	000005ad 	.word	0x000005ad
 78c:	fffffeff 	.word	0xfffffeff
 790:	000005f9 	.word	0x000005f9
 794:	fffffbff 	.word	0xfffffbff

00000798 <_i2c_m_sync_init_impl>:
	}
	return ERR_NONE;
}

static int32_t _i2c_m_sync_init_impl(struct _i2c_m_service *const service, void *const hw)
{
 798:	b5f0      	push	{r4, r5, r6, r7, lr}
 79a:	b085      	sub	sp, #20
 79c:	9002      	str	r0, [sp, #8]
	uint8_t i = _get_i2cm_index(hw);
 79e:	4b29      	ldr	r3, [pc, #164]	; (844 <_i2c_m_sync_init_impl+0xac>)
 7a0:	0008      	movs	r0, r1
{
 7a2:	000c      	movs	r4, r1
	uint8_t i = _get_i2cm_index(hw);
 7a4:	4798      	blx	r3
 7a6:	b2c3      	uxtb	r3, r0
 7a8:	9301      	str	r3, [sp, #4]
 7aa:	2318      	movs	r3, #24
 7ac:	9901      	ldr	r1, [sp, #4]
	return ((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg;
 7ae:	69e2      	ldr	r2, [r4, #28]
 7b0:	434b      	muls	r3, r1
 7b2:	4925      	ldr	r1, [pc, #148]	; (848 <_i2c_m_sync_init_impl+0xb0>)
 7b4:	18cb      	adds	r3, r1, r3
 7b6:	685d      	ldr	r5, [r3, #4]

	if (!hri_sercomi2cm_is_syncing(hw, SERCOM_I2CM_SYNCBUSY_SWRST)) {
 7b8:	07d3      	lsls	r3, r2, #31
 7ba:	d418      	bmi.n	7ee <_i2c_m_sync_init_impl+0x56>
		uint32_t mode = _i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_MODE_Msk;
 7bc:	231c      	movs	r3, #28
	tmp &= mask;
 7be:	2602      	movs	r6, #2
 7c0:	402b      	ands	r3, r5
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
 7c2:	2103      	movs	r1, #3
 7c4:	0020      	movs	r0, r4
 7c6:	4f21      	ldr	r7, [pc, #132]	; (84c <_i2c_m_sync_init_impl+0xb4>)
 7c8:	9303      	str	r3, [sp, #12]
 7ca:	47b8      	blx	r7
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
 7cc:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomi2cm_get_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_ENABLE)) {
 7ce:	4233      	tst	r3, r6
 7d0:	d005      	beq.n	7de <_i2c_m_sync_init_impl+0x46>
			hri_sercomi2cm_clear_CTRLA_ENABLE_bit(hw);
 7d2:	0020      	movs	r0, r4
 7d4:	4b1e      	ldr	r3, [pc, #120]	; (850 <_i2c_m_sync_init_impl+0xb8>)
 7d6:	4798      	blx	r3
			hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_ENABLE);
 7d8:	0031      	movs	r1, r6
 7da:	0020      	movs	r0, r4
 7dc:	47b8      	blx	r7
		}
		hri_sercomi2cm_write_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_SWRST | mode);
 7de:	2301      	movs	r3, #1
 7e0:	9a03      	ldr	r2, [sp, #12]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
 7e2:	2103      	movs	r1, #3
 7e4:	4313      	orrs	r3, r2
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
 7e6:	6023      	str	r3, [r4, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
 7e8:	0020      	movs	r0, r4
 7ea:	4b18      	ldr	r3, [pc, #96]	; (84c <_i2c_m_sync_init_impl+0xb4>)
 7ec:	4798      	blx	r3
	}
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST);

	hri_sercomi2cm_write_CTRLA_reg(hw, _i2cms[i].ctrl_a);
	hri_sercomi2cm_write_CTRLB_reg(hw, _i2cms[i].ctrl_b);
 7ee:	2618      	movs	r6, #24
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST);
 7f0:	4f16      	ldr	r7, [pc, #88]	; (84c <_i2c_m_sync_init_impl+0xb4>)
 7f2:	0020      	movs	r0, r4
 7f4:	2101      	movs	r1, #1
 7f6:	47b8      	blx	r7
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
 7f8:	6025      	str	r5, [r4, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
 7fa:	0020      	movs	r0, r4
 7fc:	2103      	movs	r1, #3
 7fe:	47b8      	blx	r7
	hri_sercomi2cm_write_CTRLB_reg(hw, _i2cms[i].ctrl_b);
 800:	9b01      	ldr	r3, [sp, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
 802:	0020      	movs	r0, r4
 804:	435e      	muls	r6, r3
 806:	4b10      	ldr	r3, [pc, #64]	; (848 <_i2c_m_sync_init_impl+0xb0>)
 808:	2104      	movs	r1, #4
 80a:	199e      	adds	r6, r3, r6
	((Sercom *)hw)->I2CM.CTRLB.reg = data;
 80c:	68b3      	ldr	r3, [r6, #8]
	hri_sercomi2cm_write_BAUD_reg(hw, _i2cms[i].baud);

	service->mode = (_i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_SPEED_Msk) >> SERCOM_I2CM_CTRLA_SPEED_Pos;
 80e:	01ad      	lsls	r5, r5, #6
 810:	6063      	str	r3, [r4, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
 812:	47b8      	blx	r7
	((Sercom *)hw)->I2CM.BAUD.reg = data;
 814:	68f3      	ldr	r3, [r6, #12]
 816:	0fa9      	lsrs	r1, r5, #30
 818:	60e3      	str	r3, [r4, #12]
	tmp = ((Sercom *)hw)->I2CM.ADDR.reg;
 81a:	6a65      	ldr	r5, [r4, #36]	; 0x24
	tmp &= ~SERCOM_I2CM_ADDR_HS;
 81c:	4a0d      	ldr	r2, [pc, #52]	; (854 <_i2c_m_sync_init_impl+0xbc>)
 81e:	9b02      	ldr	r3, [sp, #8]
 820:	402a      	ands	r2, r5
	hri_sercomi2cm_write_ADDR_HS_bit(hw, service->mode < I2C_HS ? 0 : 1);
 822:	2501      	movs	r5, #1
 824:	428d      	cmp	r5, r1
 826:	41ad      	sbcs	r5, r5
 828:	426d      	negs	r5, r5
	tmp |= value << SERCOM_I2CM_ADDR_HS_Pos;
 82a:	03ad      	lsls	r5, r5, #14
 82c:	4315      	orrs	r5, r2
	service->mode = (_i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_SPEED_Msk) >> SERCOM_I2CM_CTRLA_SPEED_Pos;
 82e:	8199      	strh	r1, [r3, #12]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
 830:	0020      	movs	r0, r4
	((Sercom *)hw)->I2CM.ADDR.reg = tmp;
 832:	6265      	str	r5, [r4, #36]	; 0x24
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
 834:	2104      	movs	r1, #4
 836:	47b8      	blx	r7

	service->trise = _i2cms[i].trise;

	return ERR_NONE;
}
 838:	2000      	movs	r0, #0
	service->trise = _i2cms[i].trise;
 83a:	8a73      	ldrh	r3, [r6, #18]
 83c:	9a02      	ldr	r2, [sp, #8]
 83e:	81d3      	strh	r3, [r2, #14]
}
 840:	b005      	add	sp, #20
 842:	bdf0      	pop	{r4, r5, r6, r7, pc}
 844:	000005cd 	.word	0x000005cd
 848:	00000be8 	.word	0x00000be8
 84c:	000005ad 	.word	0x000005ad
 850:	000005b5 	.word	0x000005b5
 854:	ffffbfff 	.word	0xffffbfff

00000858 <_i2c_m_sync_init>:
{
 858:	b570      	push	{r4, r5, r6, lr}
 85a:	0004      	movs	r4, r0
	ASSERT(i2c_dev);
 85c:	1e43      	subs	r3, r0, #1
 85e:	4198      	sbcs	r0, r3
{
 860:	000d      	movs	r5, r1
	ASSERT(i2c_dev);
 862:	4a05      	ldr	r2, [pc, #20]	; (878 <_i2c_m_sync_init+0x20>)
 864:	b2c0      	uxtb	r0, r0
 866:	4905      	ldr	r1, [pc, #20]	; (87c <_i2c_m_sync_init+0x24>)
 868:	4b05      	ldr	r3, [pc, #20]	; (880 <_i2c_m_sync_init+0x28>)
 86a:	4798      	blx	r3
	i2c_dev->hw = hw;
 86c:	6125      	str	r5, [r4, #16]
	return _i2c_m_sync_init_impl(&i2c_dev->service, hw);
 86e:	0029      	movs	r1, r5
 870:	0020      	movs	r0, r4
 872:	4b04      	ldr	r3, [pc, #16]	; (884 <_i2c_m_sync_init+0x2c>)
 874:	4798      	blx	r3
}
 876:	bd70      	pop	{r4, r5, r6, pc}
 878:	00000507 	.word	0x00000507
 87c:	00000c11 	.word	0x00000c11
 880:	00000351 	.word	0x00000351
 884:	00000799 	.word	0x00000799

00000888 <_i2c_m_sync_transfer>:
{
 888:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 88a:	0004      	movs	r4, r0
	ASSERT(i2c_dev);
 88c:	4f5b      	ldr	r7, [pc, #364]	; (9fc <_i2c_m_sync_transfer+0x174>)
 88e:	4b5c      	ldr	r3, [pc, #368]	; (a00 <_i2c_m_sync_transfer+0x178>)
{
 890:	9100      	str	r1, [sp, #0]
	void *   hw = i2c_dev->hw;
 892:	6906      	ldr	r6, [r0, #16]
	ASSERT(i2c_dev);
 894:	4a5b      	ldr	r2, [pc, #364]	; (a04 <_i2c_m_sync_transfer+0x17c>)
 896:	0039      	movs	r1, r7
 898:	2001      	movs	r0, #1
 89a:	4798      	blx	r3
	ASSERT(i2c_dev->hw);
 89c:	6920      	ldr	r0, [r4, #16]
 89e:	22b8      	movs	r2, #184	; 0xb8
 8a0:	1e43      	subs	r3, r0, #1
 8a2:	4198      	sbcs	r0, r3
 8a4:	00d2      	lsls	r2, r2, #3
 8a6:	4b56      	ldr	r3, [pc, #344]	; (a00 <_i2c_m_sync_transfer+0x178>)
 8a8:	b2c0      	uxtb	r0, r0
 8aa:	0039      	movs	r1, r7
 8ac:	4798      	blx	r3
	ASSERT(msg);
 8ae:	9800      	ldr	r0, [sp, #0]
 8b0:	4a55      	ldr	r2, [pc, #340]	; (a08 <_i2c_m_sync_transfer+0x180>)
 8b2:	1e43      	subs	r3, r0, #1
 8b4:	4198      	sbcs	r0, r3
 8b6:	0039      	movs	r1, r7
 8b8:	4b51      	ldr	r3, [pc, #324]	; (a00 <_i2c_m_sync_transfer+0x178>)
 8ba:	b2c0      	uxtb	r0, r0
 8bc:	4798      	blx	r3
	if (i2c_dev->service.msg.flags & I2C_M_BUSY) {
 8be:	2380      	movs	r3, #128	; 0x80
 8c0:	8862      	ldrh	r2, [r4, #2]
 8c2:	005b      	lsls	r3, r3, #1
 8c4:	469c      	mov	ip, r3
 8c6:	421a      	tst	r2, r3
 8c8:	d000      	beq.n	8cc <_i2c_m_sync_transfer+0x44>
 8ca:	e086      	b.n	9da <_i2c_m_sync_transfer+0x152>
	msg->flags |= I2C_M_BUSY;
 8cc:	9a00      	ldr	r2, [sp, #0]
 8ce:	9900      	ldr	r1, [sp, #0]
 8d0:	8852      	ldrh	r2, [r2, #2]
 8d2:	431a      	orrs	r2, r3
 8d4:	804a      	strh	r2, [r1, #2]
	i2c_dev->service.msg = *msg;
 8d6:	0022      	movs	r2, r4
 8d8:	c929      	ldmia	r1!, {r0, r3, r5}
 8da:	c229      	stmia	r2!, {r0, r3, r5}
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_SMEN;
 8dc:	4663      	mov	r3, ip
 8de:	6872      	ldr	r2, [r6, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
 8e0:	2104      	movs	r1, #4
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_SMEN;
 8e2:	4313      	orrs	r3, r2
 8e4:	6073      	str	r3, [r6, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
 8e6:	0030      	movs	r0, r6
 8e8:	4b48      	ldr	r3, [pc, #288]	; (a0c <_i2c_m_sync_transfer+0x184>)
 8ea:	4798      	blx	r3
	void *             hw    = i2c_dev->hw;
 8ec:	6925      	ldr	r5, [r4, #16]
	ASSERT(i2c_dev);
 8ee:	4a48      	ldr	r2, [pc, #288]	; (a10 <_i2c_m_sync_transfer+0x188>)
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
 8f0:	682b      	ldr	r3, [r5, #0]
 8f2:	0039      	movs	r1, r7
 8f4:	9301      	str	r3, [sp, #4]
 8f6:	2001      	movs	r0, #1
 8f8:	4b41      	ldr	r3, [pc, #260]	; (a00 <_i2c_m_sync_transfer+0x178>)
 8fa:	4798      	blx	r3
	if (msg->len == 1 && sclsm) {
 8fc:	6862      	ldr	r2, [r4, #4]
 8fe:	2a01      	cmp	r2, #1
 900:	d142      	bne.n	988 <_i2c_m_sync_transfer+0x100>
	tmp = (tmp & SERCOM_I2CM_CTRLA_SCLSM) >> SERCOM_I2CM_CTRLA_SCLSM_Pos;
 902:	9b01      	ldr	r3, [sp, #4]
 904:	0edb      	lsrs	r3, r3, #27
 906:	4213      	tst	r3, r2
 908:	d03e      	beq.n	988 <_i2c_m_sync_transfer+0x100>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
 90a:	2380      	movs	r3, #128	; 0x80
 90c:	686a      	ldr	r2, [r5, #4]
 90e:	02db      	lsls	r3, r3, #11
 910:	4313      	orrs	r3, r2
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
 912:	606b      	str	r3, [r5, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
 914:	2104      	movs	r1, #4
 916:	4b3d      	ldr	r3, [pc, #244]	; (a0c <_i2c_m_sync_transfer+0x184>)
 918:	0028      	movs	r0, r5
 91a:	4798      	blx	r3
	if (msg->addr & I2C_M_TEN) {
 91c:	2380      	movs	r3, #128	; 0x80
 91e:	8822      	ldrh	r2, [r4, #0]
 920:	00db      	lsls	r3, r3, #3
 922:	0057      	lsls	r7, r2, #1
 924:	421a      	tst	r2, r3
 926:	d033      	beq.n	990 <_i2c_m_sync_transfer+0x108>
		if (msg->flags & I2C_M_RD) {
 928:	8862      	ldrh	r2, [r4, #2]
 92a:	07d2      	lsls	r2, r2, #31
 92c:	d502      	bpl.n	934 <_i2c_m_sync_transfer+0xac>
			msg->flags |= I2C_M_TEN;
 92e:	8862      	ldrh	r2, [r4, #2]
 930:	4313      	orrs	r3, r2
 932:	8063      	strh	r3, [r4, #2]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
 934:	4b35      	ldr	r3, [pc, #212]	; (a0c <_i2c_m_sync_transfer+0x184>)
 936:	2104      	movs	r1, #4
 938:	0028      	movs	r0, r5
 93a:	4798      	blx	r3
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
 93c:	2280      	movs	r2, #128	; 0x80
	return ((Sercom *)hw)->I2CM.ADDR.reg;
 93e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 940:	01d2      	lsls	r2, r2, #7
 942:	401a      	ands	r2, r3
		hri_sercomi2cm_write_ADDR_reg(hw,
 944:	2380      	movs	r3, #128	; 0x80
 946:	021b      	lsls	r3, r3, #8
 948:	4313      	orrs	r3, r2
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
 94a:	4a32      	ldr	r2, [pc, #200]	; (a14 <_i2c_m_sync_transfer+0x18c>)
 94c:	4017      	ands	r7, r2
		hri_sercomi2cm_write_ADDR_reg(hw,
 94e:	431f      	orrs	r7, r3
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
 950:	0028      	movs	r0, r5
 952:	4b2e      	ldr	r3, [pc, #184]	; (a0c <_i2c_m_sync_transfer+0x184>)
	((Sercom *)hw)->I2CM.ADDR.reg = data;
 954:	626f      	str	r7, [r5, #36]	; 0x24
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
 956:	2104      	movs	r1, #4
 958:	4798      	blx	r3
	void *   hw      = i2c_dev->hw;
 95a:	2380      	movs	r3, #128	; 0x80
	} while (!(*flags & MB_FLAG) && !(*flags & SB_FLAG));
 95c:	2203      	movs	r2, #3
	void *   hw      = i2c_dev->hw;
 95e:	6920      	ldr	r0, [r4, #16]
 960:	025b      	lsls	r3, r3, #9
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
 962:	7e01      	ldrb	r1, [r0, #24]
 964:	3b01      	subs	r3, #1
 966:	b2c9      	uxtb	r1, r1
		if (timeout-- == 0) {
 968:	2b00      	cmp	r3, #0
 96a:	d001      	beq.n	970 <_i2c_m_sync_transfer+0xe8>
	} while (!(*flags & MB_FLAG) && !(*flags & SB_FLAG));
 96c:	4211      	tst	r1, r2
 96e:	d0f8      	beq.n	962 <_i2c_m_sync_transfer+0xda>
	return _sercom_i2c_sync_analyse_flags(hw, flags, msg);
 970:	0028      	movs	r0, r5
 972:	0022      	movs	r2, r4
 974:	4d28      	ldr	r5, [pc, #160]	; (a18 <_i2c_m_sync_transfer+0x190>)
 976:	47a8      	blx	r5
	} while (!(*flags & MB_FLAG) && !(*flags & SB_FLAG));
 978:	2703      	movs	r7, #3
	if (ret) {
 97a:	2800      	cmp	r0, #0
 97c:	d01a      	beq.n	9b4 <_i2c_m_sync_transfer+0x12c>
		i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
 97e:	8863      	ldrh	r3, [r4, #2]
 980:	4a26      	ldr	r2, [pc, #152]	; (a1c <_i2c_m_sync_transfer+0x194>)
 982:	4013      	ands	r3, r2
 984:	8063      	strh	r3, [r4, #2]
}
 986:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
 988:	686b      	ldr	r3, [r5, #4]
 98a:	4a25      	ldr	r2, [pc, #148]	; (a20 <_i2c_m_sync_transfer+0x198>)
 98c:	4013      	ands	r3, r2
 98e:	e7c0      	b.n	912 <_i2c_m_sync_transfer+0x8a>
		                              ((msg->addr & SEVEN_ADDR_MASK) << 1) | (msg->flags & I2C_M_RD ? I2C_M_RD : 0x0)
 990:	8863      	ldrh	r3, [r4, #2]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
 992:	2104      	movs	r1, #4
 994:	b29b      	uxth	r3, r3
 996:	9301      	str	r3, [sp, #4]
 998:	0028      	movs	r0, r5
 99a:	4b1c      	ldr	r3, [pc, #112]	; (a0c <_i2c_m_sync_transfer+0x184>)
 99c:	4798      	blx	r3
 99e:	22ff      	movs	r2, #255	; 0xff
 9a0:	9901      	ldr	r1, [sp, #4]
 9a2:	4017      	ands	r7, r2
 9a4:	3afe      	subs	r2, #254	; 0xfe
 9a6:	400a      	ands	r2, r1
 9a8:	4317      	orrs	r7, r2
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
 9aa:	2280      	movs	r2, #128	; 0x80
	return ((Sercom *)hw)->I2CM.ADDR.reg;
 9ac:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 9ae:	01d2      	lsls	r2, r2, #7
 9b0:	4013      	ands	r3, r2
 9b2:	e7cc      	b.n	94e <_i2c_m_sync_transfer+0xc6>
	while (i2c_dev->service.msg.flags & I2C_M_BUSY) {
 9b4:	2280      	movs	r2, #128	; 0x80
 9b6:	8863      	ldrh	r3, [r4, #2]
 9b8:	0052      	lsls	r2, r2, #1
 9ba:	4213      	tst	r3, r2
 9bc:	d0e3      	beq.n	986 <_i2c_m_sync_transfer+0xfe>
	void *   hw      = i2c_dev->hw;
 9be:	2380      	movs	r3, #128	; 0x80
 9c0:	6922      	ldr	r2, [r4, #16]
 9c2:	025b      	lsls	r3, r3, #9
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
 9c4:	7e11      	ldrb	r1, [r2, #24]
 9c6:	3b01      	subs	r3, #1
 9c8:	b2c9      	uxtb	r1, r1
		if (timeout-- == 0) {
 9ca:	2b00      	cmp	r3, #0
 9cc:	d007      	beq.n	9de <_i2c_m_sync_transfer+0x156>
	} while (!(*flags & MB_FLAG) && !(*flags & SB_FLAG));
 9ce:	4239      	tst	r1, r7
 9d0:	d0f8      	beq.n	9c4 <_i2c_m_sync_transfer+0x13c>
		ret = _sercom_i2c_sync_analyse_flags(hw, flags, &i2c_dev->service.msg);
 9d2:	0022      	movs	r2, r4
 9d4:	0030      	movs	r0, r6
 9d6:	47a8      	blx	r5
 9d8:	e7ec      	b.n	9b4 <_i2c_m_sync_transfer+0x12c>
		return I2C_ERR_BUSY;
 9da:	2006      	movs	r0, #6
 9dc:	e00c      	b.n	9f8 <_i2c_m_sync_transfer+0x170>
			if (msg->flags & I2C_M_STOP) {
 9de:	9b00      	ldr	r3, [sp, #0]
 9e0:	885b      	ldrh	r3, [r3, #2]
 9e2:	b21b      	sxth	r3, r3
 9e4:	2b00      	cmp	r3, #0
 9e6:	da02      	bge.n	9ee <_i2c_m_sync_transfer+0x166>
				_sercom_i2c_send_stop(hw);
 9e8:	0030      	movs	r0, r6
 9ea:	4b0e      	ldr	r3, [pc, #56]	; (a24 <_i2c_m_sync_transfer+0x19c>)
 9ec:	4798      	blx	r3
			return I2C_ERR_BUS;
 9ee:	2005      	movs	r0, #5
			i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
 9f0:	8863      	ldrh	r3, [r4, #2]
 9f2:	4a0a      	ldr	r2, [pc, #40]	; (a1c <_i2c_m_sync_transfer+0x194>)
 9f4:	4013      	ands	r3, r2
 9f6:	8063      	strh	r3, [r4, #2]
		return I2C_ERR_BUSY;
 9f8:	4240      	negs	r0, r0
 9fa:	e7c4      	b.n	986 <_i2c_m_sync_transfer+0xfe>
 9fc:	00000c11 	.word	0x00000c11
 a00:	00000351 	.word	0x00000351
 a04:	000005bf 	.word	0x000005bf
 a08:	000005c1 	.word	0x000005c1
 a0c:	000005ad 	.word	0x000005ad
 a10:	00000594 	.word	0x00000594
 a14:	000007fe 	.word	0x000007fe
 a18:	00000611 	.word	0x00000611
 a1c:	fffffeff 	.word	0xfffffeff
 a20:	fffbffff 	.word	0xfffbffff
 a24:	000005f9 	.word	0x000005f9

00000a28 <TCC1_Handler>:
/**
 * \brief TCC interrupt handler
 */
void TCC1_Handler(void)
{
	tcc_pwm_interrupt_handler(_tcc1_dev);
 a28:	4b0c      	ldr	r3, [pc, #48]	; (a5c <TCC1_Handler+0x34>)
{
 a2a:	b570      	push	{r4, r5, r6, lr}
	tcc_pwm_interrupt_handler(_tcc1_dev);
 a2c:	681c      	ldr	r4, [r3, #0]
	((Tcc *)hw)->INTFLAG.reg = TCC_INTFLAG_MC3;
}

static inline bool hri_tcc_get_interrupt_OVF_bit(const void *const hw)
{
	return (((Tcc *)hw)->INTFLAG.reg & TCC_INTFLAG_OVF) >> TCC_INTFLAG_OVF_Pos;
 a2e:	2301      	movs	r3, #1
	void *const hw = device->hw;
 a30:	6925      	ldr	r5, [r4, #16]
 a32:	6aea      	ldr	r2, [r5, #44]	; 0x2c
	if (hri_tcc_get_interrupt_OVF_bit(hw)) {
 a34:	421a      	tst	r2, r3
 a36:	d005      	beq.n	a44 <TCC1_Handler+0x1c>
}

static inline void hri_tcc_clear_interrupt_OVF_bit(const void *const hw)
{
	((Tcc *)hw)->INTFLAG.reg = TCC_INTFLAG_OVF;
 a38:	62eb      	str	r3, [r5, #44]	; 0x2c
		if (NULL != device->callback.pwm_period_cb) {
 a3a:	6823      	ldr	r3, [r4, #0]
 a3c:	2b00      	cmp	r3, #0
 a3e:	d001      	beq.n	a44 <TCC1_Handler+0x1c>
			device->callback.pwm_period_cb(device);
 a40:	0020      	movs	r0, r4
 a42:	4798      	blx	r3
	((Tcc *)hw)->INTENSET.reg = TCC_INTENSET_ERR;
}

static inline bool hri_tcc_get_INTEN_ERR_bit(const void *const hw)
{
	return (((Tcc *)hw)->INTENSET.reg & TCC_INTENSET_ERR) >> TCC_INTENSET_ERR_Pos;
 a44:	6aab      	ldr	r3, [r5, #40]	; 0x28
	if (hri_tcc_get_INTEN_ERR_bit(hw)) {
 a46:	071b      	lsls	r3, r3, #28
 a48:	d506      	bpl.n	a58 <TCC1_Handler+0x30>
	((Tcc *)hw)->INTFLAG.reg = TCC_INTFLAG_ERR;
 a4a:	2308      	movs	r3, #8
 a4c:	62eb      	str	r3, [r5, #44]	; 0x2c
		if (NULL != device->callback.pwm_error_cb) {
 a4e:	6863      	ldr	r3, [r4, #4]
 a50:	2b00      	cmp	r3, #0
 a52:	d001      	beq.n	a58 <TCC1_Handler+0x30>
			device->callback.pwm_error_cb(device);
 a54:	0020      	movs	r0, r4
 a56:	4798      	blx	r3
}
 a58:	bd70      	pop	{r4, r5, r6, pc}
 a5a:	46c0      	nop			; (mov r8, r8)
 a5c:	20000020 	.word	0x20000020

00000a60 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
 a60:	b510      	push	{r4, lr}
	system_init();
 a62:	4b01      	ldr	r3, [pc, #4]	; (a68 <atmel_start_init+0x8>)
 a64:	4798      	blx	r3
}
 a66:	bd10      	pop	{r4, pc}
 a68:	00000545 	.word	0x00000545

00000a6c <__udivsi3>:
 a6c:	2200      	movs	r2, #0
 a6e:	0843      	lsrs	r3, r0, #1
 a70:	428b      	cmp	r3, r1
 a72:	d374      	bcc.n	b5e <__udivsi3+0xf2>
 a74:	0903      	lsrs	r3, r0, #4
 a76:	428b      	cmp	r3, r1
 a78:	d35f      	bcc.n	b3a <__udivsi3+0xce>
 a7a:	0a03      	lsrs	r3, r0, #8
 a7c:	428b      	cmp	r3, r1
 a7e:	d344      	bcc.n	b0a <__udivsi3+0x9e>
 a80:	0b03      	lsrs	r3, r0, #12
 a82:	428b      	cmp	r3, r1
 a84:	d328      	bcc.n	ad8 <__udivsi3+0x6c>
 a86:	0c03      	lsrs	r3, r0, #16
 a88:	428b      	cmp	r3, r1
 a8a:	d30d      	bcc.n	aa8 <__udivsi3+0x3c>
 a8c:	22ff      	movs	r2, #255	; 0xff
 a8e:	0209      	lsls	r1, r1, #8
 a90:	ba12      	rev	r2, r2
 a92:	0c03      	lsrs	r3, r0, #16
 a94:	428b      	cmp	r3, r1
 a96:	d302      	bcc.n	a9e <__udivsi3+0x32>
 a98:	1212      	asrs	r2, r2, #8
 a9a:	0209      	lsls	r1, r1, #8
 a9c:	d065      	beq.n	b6a <__udivsi3+0xfe>
 a9e:	0b03      	lsrs	r3, r0, #12
 aa0:	428b      	cmp	r3, r1
 aa2:	d319      	bcc.n	ad8 <__udivsi3+0x6c>
 aa4:	e000      	b.n	aa8 <__udivsi3+0x3c>
 aa6:	0a09      	lsrs	r1, r1, #8
 aa8:	0bc3      	lsrs	r3, r0, #15
 aaa:	428b      	cmp	r3, r1
 aac:	d301      	bcc.n	ab2 <__udivsi3+0x46>
 aae:	03cb      	lsls	r3, r1, #15
 ab0:	1ac0      	subs	r0, r0, r3
 ab2:	4152      	adcs	r2, r2
 ab4:	0b83      	lsrs	r3, r0, #14
 ab6:	428b      	cmp	r3, r1
 ab8:	d301      	bcc.n	abe <__udivsi3+0x52>
 aba:	038b      	lsls	r3, r1, #14
 abc:	1ac0      	subs	r0, r0, r3
 abe:	4152      	adcs	r2, r2
 ac0:	0b43      	lsrs	r3, r0, #13
 ac2:	428b      	cmp	r3, r1
 ac4:	d301      	bcc.n	aca <__udivsi3+0x5e>
 ac6:	034b      	lsls	r3, r1, #13
 ac8:	1ac0      	subs	r0, r0, r3
 aca:	4152      	adcs	r2, r2
 acc:	0b03      	lsrs	r3, r0, #12
 ace:	428b      	cmp	r3, r1
 ad0:	d301      	bcc.n	ad6 <__udivsi3+0x6a>
 ad2:	030b      	lsls	r3, r1, #12
 ad4:	1ac0      	subs	r0, r0, r3
 ad6:	4152      	adcs	r2, r2
 ad8:	0ac3      	lsrs	r3, r0, #11
 ada:	428b      	cmp	r3, r1
 adc:	d301      	bcc.n	ae2 <__udivsi3+0x76>
 ade:	02cb      	lsls	r3, r1, #11
 ae0:	1ac0      	subs	r0, r0, r3
 ae2:	4152      	adcs	r2, r2
 ae4:	0a83      	lsrs	r3, r0, #10
 ae6:	428b      	cmp	r3, r1
 ae8:	d301      	bcc.n	aee <__udivsi3+0x82>
 aea:	028b      	lsls	r3, r1, #10
 aec:	1ac0      	subs	r0, r0, r3
 aee:	4152      	adcs	r2, r2
 af0:	0a43      	lsrs	r3, r0, #9
 af2:	428b      	cmp	r3, r1
 af4:	d301      	bcc.n	afa <__udivsi3+0x8e>
 af6:	024b      	lsls	r3, r1, #9
 af8:	1ac0      	subs	r0, r0, r3
 afa:	4152      	adcs	r2, r2
 afc:	0a03      	lsrs	r3, r0, #8
 afe:	428b      	cmp	r3, r1
 b00:	d301      	bcc.n	b06 <__udivsi3+0x9a>
 b02:	020b      	lsls	r3, r1, #8
 b04:	1ac0      	subs	r0, r0, r3
 b06:	4152      	adcs	r2, r2
 b08:	d2cd      	bcs.n	aa6 <__udivsi3+0x3a>
 b0a:	09c3      	lsrs	r3, r0, #7
 b0c:	428b      	cmp	r3, r1
 b0e:	d301      	bcc.n	b14 <__udivsi3+0xa8>
 b10:	01cb      	lsls	r3, r1, #7
 b12:	1ac0      	subs	r0, r0, r3
 b14:	4152      	adcs	r2, r2
 b16:	0983      	lsrs	r3, r0, #6
 b18:	428b      	cmp	r3, r1
 b1a:	d301      	bcc.n	b20 <__udivsi3+0xb4>
 b1c:	018b      	lsls	r3, r1, #6
 b1e:	1ac0      	subs	r0, r0, r3
 b20:	4152      	adcs	r2, r2
 b22:	0943      	lsrs	r3, r0, #5
 b24:	428b      	cmp	r3, r1
 b26:	d301      	bcc.n	b2c <__udivsi3+0xc0>
 b28:	014b      	lsls	r3, r1, #5
 b2a:	1ac0      	subs	r0, r0, r3
 b2c:	4152      	adcs	r2, r2
 b2e:	0903      	lsrs	r3, r0, #4
 b30:	428b      	cmp	r3, r1
 b32:	d301      	bcc.n	b38 <__udivsi3+0xcc>
 b34:	010b      	lsls	r3, r1, #4
 b36:	1ac0      	subs	r0, r0, r3
 b38:	4152      	adcs	r2, r2
 b3a:	08c3      	lsrs	r3, r0, #3
 b3c:	428b      	cmp	r3, r1
 b3e:	d301      	bcc.n	b44 <__udivsi3+0xd8>
 b40:	00cb      	lsls	r3, r1, #3
 b42:	1ac0      	subs	r0, r0, r3
 b44:	4152      	adcs	r2, r2
 b46:	0883      	lsrs	r3, r0, #2
 b48:	428b      	cmp	r3, r1
 b4a:	d301      	bcc.n	b50 <__udivsi3+0xe4>
 b4c:	008b      	lsls	r3, r1, #2
 b4e:	1ac0      	subs	r0, r0, r3
 b50:	4152      	adcs	r2, r2
 b52:	0843      	lsrs	r3, r0, #1
 b54:	428b      	cmp	r3, r1
 b56:	d301      	bcc.n	b5c <__udivsi3+0xf0>
 b58:	004b      	lsls	r3, r1, #1
 b5a:	1ac0      	subs	r0, r0, r3
 b5c:	4152      	adcs	r2, r2
 b5e:	1a41      	subs	r1, r0, r1
 b60:	d200      	bcs.n	b64 <__udivsi3+0xf8>
 b62:	4601      	mov	r1, r0
 b64:	4152      	adcs	r2, r2
 b66:	4610      	mov	r0, r2
 b68:	4770      	bx	lr
 b6a:	e7ff      	b.n	b6c <__udivsi3+0x100>
 b6c:	b501      	push	{r0, lr}
 b6e:	2000      	movs	r0, #0
 b70:	f000 f806 	bl	b80 <__aeabi_idiv0>
 b74:	bd02      	pop	{r1, pc}
 b76:	46c0      	nop			; (mov r8, r8)

00000b78 <__aeabi_uidivmod>:
 b78:	2900      	cmp	r1, #0
 b7a:	d0f7      	beq.n	b6c <__udivsi3+0x100>
 b7c:	e776      	b.n	a6c <__udivsi3>
 b7e:	4770      	bx	lr

00000b80 <__aeabi_idiv0>:
 b80:	4770      	bx	lr
 b82:	46c0      	nop			; (mov r8, r8)

00000b84 <__libc_init_array>:
 b84:	b570      	push	{r4, r5, r6, lr}
 b86:	2600      	movs	r6, #0
 b88:	4d0c      	ldr	r5, [pc, #48]	; (bbc <__libc_init_array+0x38>)
 b8a:	4c0d      	ldr	r4, [pc, #52]	; (bc0 <__libc_init_array+0x3c>)
 b8c:	1b64      	subs	r4, r4, r5
 b8e:	10a4      	asrs	r4, r4, #2
 b90:	42a6      	cmp	r6, r4
 b92:	d109      	bne.n	ba8 <__libc_init_array+0x24>
 b94:	2600      	movs	r6, #0
 b96:	f000 f849 	bl	c2c <_init>
 b9a:	4d0a      	ldr	r5, [pc, #40]	; (bc4 <__libc_init_array+0x40>)
 b9c:	4c0a      	ldr	r4, [pc, #40]	; (bc8 <__libc_init_array+0x44>)
 b9e:	1b64      	subs	r4, r4, r5
 ba0:	10a4      	asrs	r4, r4, #2
 ba2:	42a6      	cmp	r6, r4
 ba4:	d105      	bne.n	bb2 <__libc_init_array+0x2e>
 ba6:	bd70      	pop	{r4, r5, r6, pc}
 ba8:	00b3      	lsls	r3, r6, #2
 baa:	58eb      	ldr	r3, [r5, r3]
 bac:	4798      	blx	r3
 bae:	3601      	adds	r6, #1
 bb0:	e7ee      	b.n	b90 <__libc_init_array+0xc>
 bb2:	00b3      	lsls	r3, r6, #2
 bb4:	58eb      	ldr	r3, [r5, r3]
 bb6:	4798      	blx	r3
 bb8:	3601      	adds	r6, #1
 bba:	e7f2      	b.n	ba2 <__libc_init_array+0x1e>
 bbc:	00000c38 	.word	0x00000c38
 bc0:	00000c38 	.word	0x00000c38
 bc4:	00000c38 	.word	0x00000c38
 bc8:	00000c3c 	.word	0x00000c3c
 bcc:	682f2e2e 	.word	0x682f2e2e
 bd0:	732f6c61 	.word	0x732f6c61
 bd4:	682f6372 	.word	0x682f6372
 bd8:	695f6c61 	.word	0x695f6c61
 bdc:	6d5f6332 	.word	0x6d5f6332
 be0:	6e79735f 	.word	0x6e79735f
 be4:	00632e63 	.word	0x00632e63

00000be8 <_i2cms>:
 be8:	00000002 00200014 00000100 0000e6e5     ...... .........
 bf8:	00d70000 02dc6c00                       .....l..

00000c00 <sercomspi_regs>:
	...
 c10:	2f2e2e00 2f6c7068 63726573 682f6d6f     .../hpl/sercom/h
 c20:	735f6c70 6f637265 00632e6d              pl_sercom.c.

00000c2c <_init>:
 c2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c2e:	46c0      	nop			; (mov r8, r8)
 c30:	bcf8      	pop	{r3, r4, r5, r6, r7}
 c32:	bc08      	pop	{r3}
 c34:	469e      	mov	lr, r3
 c36:	4770      	bx	lr

00000c38 <__init_array_start>:
 c38:	00000129 	.word	0x00000129

00000c3c <_fini>:
 c3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c3e:	46c0      	nop			; (mov r8, r8)
 c40:	bcf8      	pop	{r3, r4, r5, r6, r7}
 c42:	bc08      	pop	{r3}
 c44:	469e      	mov	lr, r3
 c46:	4770      	bx	lr

00000c48 <__fini_array_start>:
 c48:	000000fd 	.word	0x000000fd
